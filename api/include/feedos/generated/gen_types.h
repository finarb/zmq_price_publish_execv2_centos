/*
 * This file was generated by the PDUGenerator.
 * Don't modify the content manually.
 *
 */

#ifndef FEEDOS_GEN_PDU_TYPES_H
#define FEEDOS_GEN_PDU_TYPES_H

/************************************/
/** FeedOS                         **/
/**                                **/
/** copyright QuantHouse           **/
/************************************/

/** @file
  * 
  * Definition of all types defined in XML description
  *
  */


#ifndef FEEDOS_DONT_INCLUDE_OLD_HEADERS
#	include "fos/pduext/BasicTypes.h"
#	include "fos/pduext/pdu_return_codes.h"
#endif

#include <vector>
#include <map>
//#include <hash_map>

namespace FeedOS {

//#ifdef FEEDOS_DONT_INCLUDE_OLD_HEADERS
namespace Types {
//#endif

	void type_dump_usage(std::string const & strtype,std::ostream & o);
	void all_type_dump_available(std::ostream & o);

//	class OrderBookEntryExtended; void init_feedos_type (OrderBookEntryExtended &);

	inline void init_feedos_type (Enum			& v) 	{ v=0; }
	inline void init_feedos_type (uint8			& v) 	{ v=0; }
	inline void init_feedos_type (uint16		& v) 	{ v=0; }
	inline void init_feedos_type (uint32		& v) 	{ v=0; }
	inline void init_feedos_type (uint64		& v) 	{ v=0; }
	inline void init_feedos_type (int8			& v) 	{ v=0; }
	inline void init_feedos_type (int16			& v) 	{ v=0; }
	inline void init_feedos_type (int32			& v) 	{ v=0; }
	inline void init_feedos_type (int64			& v) 	{ v=0; }
	inline void init_feedos_type (float64		& v) 	{ v=0; }
	inline void init_feedos_type (bool			& v) 	{ v=false; }
	inline void init_feedos_type (char			& v) 	{ v=' '; }
	inline void init_feedos_type (ReturnCode	& v) 	{ v=RC_OK; }
	inline void init_feedos_type (std::string	& v) 	{ v.clear(); }
	inline void init_feedos_type (BinaryBuffer	& v) 	{ v.clear(); }

	inline void init_feedos_type (Timestamp					& v) 	{ v.set_to_null(); }
	inline void init_feedos_type (Any						& v) 	{ v.set_invalid(); }
	inline void init_feedos_type (FOSMarketId				& v) 	{ v.set_invalid(); }
	inline void init_feedos_type (FOSInstrumentCode			& v) 	{ v.set_invalid(); }
	inline void init_feedos_type (LocalInstrumentCode		& v) 	{ v.set_invalid(); }
	inline void init_feedos_type (PolymorphicInstrumentCode	& v) 	{ v.set_invalid(); }
	inline void init_feedos_type (FOSPrice & v) 					{ v.set(0); }
	inline void init_feedos_type (FOSInteger & v)					{ v.set(0); }
	
	template <typename T>
	inline void init_feedos_type (std::vector<T> & v)		{ v.clear(); }

	template <typename K,typename D>
	inline void init_feedos_type (std::map<K,D> & v)		{ v.clear(); }

//	template <typename K,typename D>
//	inline void init_feedos_type (std::hash_map<K,D> & v)	{ v.clear(); }

//#ifdef FEEDOS_DONT_INCLUDE_OLD_HEADERS
}
//#endif

}

namespace FeedOS {

//#ifdef FEEDOS_DONT_INCLUDE_OLD_HEADERS
namespace Types {
//#endif
/**

			Distinct kinds of lookup request mode.
		
*/
enum LookupMode {
	LookupMode_Narrow /** Precise search */,
	LookupMode_Wide /** Extended search */
};

inline void init_feedos_type (LookupMode & v) 	{ v=(LookupMode)0; }

/**

			Reason of an order modification or deletion in MarketSheet.
		
*/
enum OrderModificationReason {
	OrderModificationReason_UnknownOrCancellation /** Default value, never sent */,
	OrderModificationReason_Execution /** Order has been partially or fully executed */
};

inline void init_feedos_type (OrderModificationReason & v) 	{ v=(OrderModificationReason)0; }

/**

			see MarketNews
		
*/
enum FIXMarketNewsUrgency {
	FIXMarketNewsUrgency_Normal,
	FIXMarketNewsUrgency_Flash,
	FIXMarketNewsUrgency_Background
};

inline void init_feedos_type (FIXMarketNewsUrgency & v) 	{ v=(FIXMarketNewsUrgency)0; }

/**

			FIX 5.0sp2 FIXML @NewsCatgy
		
*/
enum FIXNewsCategory {
	FIXNewsCategory_CompanyNews,
	FIXNewsCategory_MarketplaceNews,
	FIXNewsCategory_FinancialMarketNews,
	FIXNewsCategory_TechnicalNews
};

inline void init_feedos_type (FIXNewsCategory & v) 	{ v=(FIXNewsCategory)0; }

/**

			method of trading. From FIX 4.4 tag 338
		
*/
enum FIXTradSesMethod {
	FIXTradSesMethod_Unknown,
	FIXTradSesMethod_Electronic,
	FIXTradSesMethod_OpenOutcry,
	FIXTradSesMethod_TwoParty
};

inline void init_feedos_type (FIXTradSesMethod & v) 	{ v=(FIXTradSesMethod)0; }

/**

			method of trading. From FIX 4.4
		
*/
enum FIXTradSesMode {
	FIXTradSesMode_Unknown,
	FIXTradSesMode_Testing,
	FIXTradSesMode_Simulated,
	FIXTradSesMode_Production
};

inline void init_feedos_type (FIXTradSesMode & v) 	{ v=(FIXTradSesMode)0; }

/**

			status of a trading session. From FIX 4.4
		
*/
enum FIXTradSesStatus {
	FIXTradSesStatus_Unknown,
	FIXTradSesStatus_Halted,
	FIXTradSesStatus_Open,
	FIXTradSesStatus_Closed,
	FIXTradSesStatus_PreOpen,
	FIXTradSesStatus_PreClose
};

inline void init_feedos_type (FIXTradSesStatus & v) 	{ v=(FIXTradSesStatus)0; }

/**

			trading status of an instrument. From FIX 5.0 sp1
		
*/
enum FIXSecurityTradingStatus {
	FIXSecurityTradingStatus_UNKNOWN,
	FIXSecurityTradingStatus_OpeningDelay,
	FIXSecurityTradingStatus_TradingHalt,
	FIXSecurityTradingStatus_Resume,
	FIXSecurityTradingStatus_NoOpenNoResume,
	FIXSecurityTradingStatus_PriceIndication,
	FIXSecurityTradingStatus_TradingRangeIndication,
	FIXSecurityTradingStatus_MarketImbalanceBuy,
	FIXSecurityTradingStatus_MarketImbalanceSell,
	FIXSecurityTradingStatus_MarketOnCloseImbalanceBuy,
	FIXSecurityTradingStatus_MarketOnCloseImbalanceSell,
	FIXSecurityTradingStatus_NOT_ASSIGNED_11,
	FIXSecurityTradingStatus_NoMarketImbalance,
	FIXSecurityTradingStatus_NoMarketOnCloseImbalance,
	FIXSecurityTradingStatus_ITSPreOpening,
	FIXSecurityTradingStatus_NewPriceIndication,
	FIXSecurityTradingStatus_TradeDisseminationTime,
	FIXSecurityTradingStatus_ReadyToTrade /** start of session */,
	FIXSecurityTradingStatus_NotAvailableForTrading /** end of session */,
	FIXSecurityTradingStatus_NotTradedOnThisMarket,
	FIXSecurityTradingStatus_UnknownOrInvalid,
	FIXSecurityTradingStatus_PreOpen,
	FIXSecurityTradingStatus_OpeningRotation,
	FIXSecurityTradingStatus_FastMarket,
	FIXSecurityTradingStatus_PreCross,
	FIXSecurityTradingStatus_Cross
};

inline void init_feedos_type (FIXSecurityTradingStatus & v) 	{ v=(FIXSecurityTradingStatus)0; }

/**

			SEC Rule 201 of Regulation SHO. 
			Restriction on the prices at which securities may be sold short after a circuit breaker has been triggered (10% decrease of the last closing price)
		
*/
enum FOSRegSHOAction {
	FOSRegSHOAction_UNKNOWN /** Unknown value, never sent */,
	FOSRegSHOAction_NoPriceTest /** No short sale price restriction */,
	FOSRegSHOAction_PriceTestInEffect /** Short sale price restriction in progress */,
	FOSRegSHOAction_PriceTestRemainsInEffect /** Short sale price restriction remains in effect for a second business day. If retriggered the second day, a PriceTestInEffect is used instead. */
};

inline void init_feedos_type (FOSRegSHOAction & v) 	{ v=(FOSRegSHOAction)0; }

/**

		  A trade impact indicator holds the market information of the
		  eligibility of a trade.
		
*/
enum QuotationTradeImpactIndicator {
	QuotationTradeImpactIndicator_HasOpen,
	QuotationTradeImpactIndicator_HasHighLow,
	QuotationTradeImpactIndicator_HasLast,
	QuotationTradeImpactIndicator_HasVolume,
	QuotationTradeImpactIndicator_HasOffBookVolume,
	QuotationTradeImpactIndicator_HasVWAP,
	QuotationTradeImpactIndicator_reserved_6,
	QuotationTradeImpactIndicator_reserved_7,
	QuotationTradeImpactIndicator_reserved_8,
	QuotationTradeImpactIndicator_reserved_9,
	QuotationTradeImpactIndicator_reserved_10,
	QuotationTradeImpactIndicator_reserved_11,
	QuotationTradeImpactIndicator_reserved_12,
	QuotationTradeImpactIndicator_reserved_13,
	QuotationTradeImpactIndicator_reserved_14,
	QuotationTradeImpactIndicator_reserved_15,
	QuotationTradeImpactIndicator_Open,
	QuotationTradeImpactIndicator_HighLow,
	QuotationTradeImpactIndicator_Last,
	QuotationTradeImpactIndicator_Volume,
	QuotationTradeImpactIndicator_OffBookVolume,
	QuotationTradeImpactIndicator_VWAP,
	QuotationTradeImpactIndicator_reserved_22,
	QuotationTradeImpactIndicator_reserved_23,
	QuotationTradeImpactIndicator_reserved_24,
	QuotationTradeImpactIndicator_reserved_25,
	QuotationTradeImpactIndicator_reserved_26,
	QuotationTradeImpactIndicator_reserved_27,
	QuotationTradeImpactIndicator_reserved_28,
	QuotationTradeImpactIndicator_reserved_29,
	QuotationTradeImpactIndicator_reserved_30,
	QuotationTradeImpactIndicator_reserved_31
};

inline void init_feedos_type (QuotationTradeImpactIndicator & v) 	{ v=(QuotationTradeImpactIndicator)0; }

/**

			From FIX 4.4
		
*/
enum QuotationUpdateContent {
	QuotationUpdateContent_TradingStatus,
	QuotationUpdateContent_Bid,
	QuotationUpdateContent_Ask,
	QuotationUpdateContent_LastPrice,
	QuotationUpdateContent_LastTradeQty,
	QuotationUpdateContent_Open,
	QuotationUpdateContent_Close,
	QuotationUpdateContent_High,
	QuotationUpdateContent_Low,
	QuotationUpdateContent_OCHL_daily,
	QuotationUpdateContent_OtherValues,
	QuotationUpdateContent_OpeningNextCalendarDay,
	QuotationUpdateContent_Context,
	QuotationUpdateContent_OffBookTrade,
	QuotationUpdateContent_ChangeBusinessDay,
	QuotationUpdateContent_Session,
	QuotationUpdateContent_reserved_16,
	QuotationUpdateContent_reserved_17,
	QuotationUpdateContent_reserved_18,
	QuotationUpdateContent_reserved_19,
	QuotationUpdateContent_reserved_20,
	QuotationUpdateContent_reserved_21,
	QuotationUpdateContent_reserved_22,
	QuotationUpdateContent_reserved_23,
	QuotationUpdateContent_reserved_24,
	QuotationUpdateContent_reserved_25,
	QuotationUpdateContent_reserved_26,
	QuotationUpdateContent_reserved_27,
	QuotationUpdateContent_reserved_28,
	QuotationUpdateContent_reserved_29,
	QuotationUpdateContent_reserved_30,
	QuotationUpdateContent_reserved_31_presence_map
};

inline void init_feedos_type (QuotationUpdateContent & v) 	{ v=(QuotationUpdateContent)0; }

/**

			action to apply
		
*/
enum OrderBookDeltaAction {
	OrderBookDeltaAction_ALLClearFromLevel /** delete ALL entries, starting from Level (included) */,
	OrderBookDeltaAction_BidClearFromLevel /** delete Bid entries, starting from Level (included) */,
	OrderBookDeltaAction_AskClearFromLevel /** delete Ask entries, starting from Level (included) */,
	OrderBookDeltaAction_BidInsertAtLevel /** insert line (Price,Qty) at Level and shift subsequent lines down */,
	OrderBookDeltaAction_AskInsertAtLevel /** insert line (Price,Qty) at Level and shift subsequent lines down */,
	OrderBookDeltaAction_BidRemoveLevel /** remove line at Level and shift subsequent lines up */,
	OrderBookDeltaAction_AskRemoveLevel /** remove line at Level and shift subsequent lines up */,
	OrderBookDeltaAction_BidChangeQtyAtLevel /** change Qty at Level */,
	OrderBookDeltaAction_AskChangeQtyAtLevel /** change Qty at Level */,
	OrderBookDeltaAction_BidRemoveLevelAndAppend /** remove line at Level, shift subsequent lines up and append a new limit at MaxVisibleDepth-1 */,
	OrderBookDeltaAction_AskRemoveLevelAndAppend /** remove line at Level, shift subsequent lines up and append a new limit at MaxVisibleDepth-1 */
};

inline void init_feedos_type (OrderBookDeltaAction & v) 	{ v=(OrderBookDeltaAction)0; }

/**

		
*/
enum presencemap_MBLOverlapRefresh {
	presencemap_MBLOverlapRefresh_LayerId_is_not_zero,
	presencemap_MBLOverlapRefresh_BidReset,
	presencemap_MBLOverlapRefresh_BidData,
	presencemap_MBLOverlapRefresh_AskReset,
	presencemap_MBLOverlapRefresh_AskData,
	presencemap_MBLOverlapRefresh_OtherValues,
	presencemap_MBLOverlapRefresh_reserved_7
};

inline void init_feedos_type (presencemap_MBLOverlapRefresh & v) 	{ v=(presencemap_MBLOverlapRefresh)0; }

/**

		
*/
enum presencemap_MBLDeltaRefresh {
	presencemap_MBLDeltaRefresh_LayerId_is_not_zero,
	presencemap_MBLDeltaRefresh_OtherValues,
	presencemap_MBLDeltaRefresh_Action_2,
	presencemap_MBLDeltaRefresh_Action_3,
	presencemap_MBLDeltaRefresh_Action_4,
	presencemap_MBLDeltaRefresh_Action_5,
	presencemap_MBLDeltaRefresh_ContinuationFlag,
	presencemap_MBLDeltaRefresh_reserved_7
};

inline void init_feedos_type (presencemap_MBLDeltaRefresh & v) 	{ v=(presencemap_MBLDeltaRefresh)0; }

/**

		
*/
enum presencemap_MBLLayer {
	presencemap_MBLLayer_LayerId_is_not_zero,
	presencemap_MBLLayer_BidData,
	presencemap_MBLLayer_AskData,
	presencemap_MBLLayer_OtherValues,
	presencemap_MBLLayer_reserved_4,
	presencemap_MBLLayer_reserved_5,
	presencemap_MBLLayer_reserved_6,
	presencemap_MBLLayer_reserved_7
};

inline void init_feedos_type (presencemap_MBLLayer & v) 	{ v=(presencemap_MBLLayer)0; }

/**

		
*/
enum NewsCategory {
	NewsCategory_Unknown /** default category */,
	NewsCategory_category1 /** TODO */,
	NewsCategory_category2 /** TODO */
};

inline void init_feedos_type (NewsCategory & v) 	{ v=(NewsCategory)0; }

/**

		
*/
enum NewsType {
	NewsType_Unknown /** default type */,
	NewsType_type1 /** TODO */,
	NewsType_type2 /** TODO */
};

inline void init_feedos_type (NewsType & v) 	{ v=(NewsType)0; }

/**

			fields identifiers
		
*/
enum NewsFieldId {
	NewsFieldId_Category /** (use NewsCategory values into Enum) filter checks equality */,
	NewsFieldId_Type /** (use NewsType values into Enum) filter checks equality */,
	NewsFieldId_Submitter /** (use String values) filter checks equality */,
	NewsFieldId_Language /** (use String values) filter checks equality */,
	NewsFieldId_SubmitDate /** (use Timestamp values) filter checks that SubmitDate >= the given value */,
	NewsFieldId_ModifyDate /** (use Timestamp values) filter checks that ModifyDate >= the given value */,
	NewsFieldId_ExpirationDate /** no filtering */,
	NewsFieldId_Headline /** (use String values) filter checks for a substring, case ignored */,
	NewsFieldId_Keywords /** (use String values) filter checks that given value is present in list (as a substring, case ignored) */,
	NewsFieldId_RelatedMarket /** (use uint16 value) filter checks equality */,
	NewsFieldId_RelatedCompanies /** (use String values) filter checks that given value is present in list (as a substring, case ignored) */,
	NewsFieldId_RelatedInstruments /** (use uint32 values) filter checks that given value is present in list */,
	NewsFieldId_Body /** (use String values) filter checks for a substring, case ignored */,
	NewsFieldId_URL /** (use String values) filter checks for a substring, case ignored */
};

inline void init_feedos_type (NewsFieldId & v) 	{ v=(NewsFieldId)0; }

/**

			News events'classification
		
*/
enum NewsEventType {
	NewsEventType_Spread /** News spreading */,
	NewsEventType_Correction /** News corrected */,
	NewsEventType_Removal /** News removed */,
	NewsEventType_Backfill /** News resent */
};

inline void init_feedos_type (NewsEventType & v) 	{ v=(NewsEventType)0; }

/**

		
*/
enum MulticastDataRecoveryMode {
	MulticastDataRecoveryMode_Range /** send all data frames in the given range */,
	MulticastDataRecoveryMode_FromBegin /** send data from the given Begin up to the newest stored */,
	MulticastDataRecoveryMode_UpToEnd /** send data from the oldest up to the given End */
};

inline void init_feedos_type (MulticastDataRecoveryMode & v) 	{ v=(MulticastDataRecoveryMode)0; }

/**

			Tells how to handle the case where instrument already exists
		
*/
enum AllocateNewInstrumentPolicy {
	AllocateNewInstrumentPolicy_DoNotOverwrite /** if instrument already exists, fail. */,
	AllocateNewInstrumentPolicy_Overwrite /** if instrument already exists, overwrite it. */,
	AllocateNewInstrumentPolicy_ResetAndOverwrite /** if instrument already exists, reset attributes then overwrite it. */
};

inline void init_feedos_type (AllocateNewInstrumentPolicy & v) 	{ v=(AllocateNewInstrumentPolicy)0; }

/**

			state of Market Data Feed
		
*/
enum FeedState {
	FeedState_Active /** normal with activity */,
	FeedState_ProbablyNormal /** looks like normal */,
	FeedState_ProbablyDisrupted /** looks like disrupted */,
	FeedState_Disrupted_TechnicalLevel /** not usable (technical reasons) */,
	FeedState_Disrupted_ExchangeLevel /** not usable (N/A at exchange level) */
};

inline void init_feedos_type (FeedState & v) 	{ v=(FeedState)0; }

/**

			state of FeedHandler regarding resilicency
		
*/
enum FeedHandlerResiliencyRole {
	FeedHandlerResiliencyRole_Single /** no resiliency */,
	FeedHandlerResiliencyRole_Primary /** primary feedhandler */,
	FeedHandlerResiliencyRole_ActiveSecondary /** secondary feedhandler (active mode) */,
	FeedHandlerResiliencyRole_PassiveSecondary /** secondary feedhandler (passive mode) */
};

inline void init_feedos_type (FeedHandlerResiliencyRole & v) 	{ v=(FeedHandlerResiliencyRole)0; }

/**

			status of a given feedhandler regarding resiliency
		
*/
enum FeedHandlerResiliencyStatus {
	FeedHandlerResiliencyStatus_Unknown /** unknown */,
	FeedHandlerResiliencyStatus_Unable /** Unable to broadcast messages */,
	FeedHandlerResiliencyStatus_ProbablyUnable /** Link to the market looks broken */,
	FeedHandlerResiliencyStatus_ProbablyReady /** Waiting for handover, no data are being received */,
	FeedHandlerResiliencyStatus_Ready /** Waiting for handover, some data are being received */,
	FeedHandlerResiliencyStatus_Active /** Data is being broadcasted */,
	FeedHandlerResiliencyStatus_ProbablyActive /** Will broadcast data as they arrive */
};

inline void init_feedos_type (FeedHandlerResiliencyStatus & v) 	{ v=(FeedHandlerResiliencyStatus)0; }

/**

			tells how a feed is made accessible (transport/query)
		
*/
enum FeedAccessMethod {
	FeedAccessMethod_NONE /** not available */,
	FeedAccessMethod_tcp_on_demand /** point-to-point-subscription, per-subject */,
	FeedAccessMethod_tcp_full /** point-to-point-subscription, full */,
	FeedAccessMethod_multicast_on_demand /** dissemination, per-subject */,
	FeedAccessMethod_multicast_full /** dissemination, full */
};

inline void init_feedos_type (FeedAccessMethod & v) 	{ v=(FeedAccessMethod)0; }

/**

			reason why an order has been rejected.
		
*/
enum OrderRejectReason {
	OrderRejectReason_RuleTriggeredAtAgent,
	OrderRejectReason_RuleTriggeredAtSupervisor,
	OrderRejectReason_RejectedByBlackMode,
	OrderRejectReason_RejectedBecauseOfFlagNowOrNever,
	OrderRejectReason_BadOrderFormat,
	OrderRejectReason_AgentIsNotReady,
	OrderRejectReason_Unknown
};

inline void init_feedos_type (OrderRejectReason & v) 	{ v=(OrderRejectReason)0; }

/**

			Type of event that leads to adjustment
		
*/
enum AdjustmentFactorEventType {
	AdjustmentFactorEventType_reserved_0,
	AdjustmentFactorEventType_RightsSameClass,
	AdjustmentFactorEventType_RightsDifferentClass,
	AdjustmentFactorEventType_EntitlementSameClass,
	AdjustmentFactorEventType_EntitlementDifferentClass,
	AdjustmentFactorEventType_Subdivision,
	AdjustmentFactorEventType_Consolidation,
	AdjustmentFactorEventType_reserved_7,
	AdjustmentFactorEventType_reserved_8,
	AdjustmentFactorEventType_Demerger,
	AdjustmentFactorEventType_CapitalReturn,
	AdjustmentFactorEventType_Distribution,
	AdjustmentFactorEventType_reserved_12,
	AdjustmentFactorEventType_BonusSameClass,
	AdjustmentFactorEventType_BonusDifferentClass,
	AdjustmentFactorEventType_reserved_15,
	AdjustmentFactorEventType_CapitalReduction,
	AdjustmentFactorEventType_CashDividend,
	AdjustmentFactorEventType_ScriptDividendSameClass,
	AdjustmentFactorEventType_reserved_19,
	AdjustmentFactorEventType_ScriptDividendDifferentClass,
	AdjustmentFactorEventType_CapitalCall,
	AdjustmentFactorEventType_reserved_22,
	AdjustmentFactorEventType_reserved_23,
	AdjustmentFactorEventType_reserved_24,
	AdjustmentFactorEventType_reserved_25,
	AdjustmentFactorEventType_reserved_26,
	AdjustmentFactorEventType_reserved_27,
	AdjustmentFactorEventType_reserved_28,
	AdjustmentFactorEventType_reserved_29,
	AdjustmentFactorEventType_reserved_30
};

inline void init_feedos_type (AdjustmentFactorEventType & v) 	{ v=(AdjustmentFactorEventType)0; }

/**

			Describes the content of a TradeCancelCorrection notification
		
*/
enum TradeCancelCorrectionContent {
	TradeCancelCorrectionContent_IsCorrection /** unset: cancel, set: correction */,
	TradeCancelCorrectionContent_IsFromVenue /** unset: manual, set: from venue */,
	TradeCancelCorrectionContent_CorrectedValues /** CorrectedValues field presence */,
	TradeCancelCorrectionContent_OffBookTrade,
	TradeCancelCorrectionContent_CurrentSession /** set: the trade belongs to the current session */,
	TradeCancelCorrectionContent_reserved_5,
	TradeCancelCorrectionContent_reserved_6,
	TradeCancelCorrectionContent_reserved_7
};

inline void init_feedos_type (TradeCancelCorrectionContent & v) 	{ v=(TradeCancelCorrectionContent)0; }

/**

			type of DailyExtended point to get when requesting the quotation daily extended database
		
*/
enum DailyExtPointType {
	DailyExtPointType_DailyOnly /** gets only daily data */,
	DailyExtPointType_SessionOnly /** gets only session data */,
	DailyExtPointType_DailyAndSession /** gets both daily and session data */
};

inline void init_feedos_type (DailyExtPointType & v) 	{ v=(DailyExtPointType)0; }

	template<typename T>
	void init_feedos_type (T & v)
	{ v._reset(); }

typedef std::vector<PolymorphicInstrumentCode> ListOfPolymorphicInstrumentCode;

typedef std::vector<FOSInstrumentCode> ListOfFOSInstrumentCode;

typedef std::vector<String> ListOfString;

typedef std::vector<FOSMarketId> ListOfFOSMarketId;

typedef std::vector<BinaryBuffer> ListOfBinaryBuffer;

/**
	
*/
typedef uint16 TagNumber;

/**
	
*/
typedef TagNumber ReferentialTagNumber;

/**
	
*/
typedef TagNumber QuotationTagNumber;

typedef std::vector<TagNumber> ListOfTagNumber;

typedef std::vector<ReferentialTagNumber> ListOfReferentialTagNumber;

typedef std::vector<QuotationTagNumber> ListOfQuotationTagNumber;

/**

			ID + value, used to store referential (static) data or quotation values
		
*/
class TagNumAndValue
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Num);
			init_feedos_type (m_Value);
		}

		TagNumAndValue() { reset(); }

		inline TagNumAndValue(TagNumAndValue const & c) :
			m_Num(c.m_Num),
			m_Value(c.m_Value)
		{}
		TagNumAndValue(TagNumber num, Any const & value) :
			m_Num(num),
			m_Value(value)
		{}

		TagNumAndValue const & operator =(TagNumAndValue const & c)
		{
			m_Num = c.m_Num;
			m_Value = c.m_Value;
			return *this;
		}

		bool operator ==(TagNumAndValue const & c) const
		{
			return (m_Num == c.m_Num) && (m_Value == c.m_Value);
		}

	public:
		TagNumber getNum() const { return m_Num; }
		TagNumber & getNum() { return m_Num; }
		Any const & getValue() const { return m_Value; }
		Any & getValue() { return m_Value; }

	public:
		void setNum(TagNumber num) { m_Num = num; }
		void setValue(Any const & value) { m_Value = value; }

	protected:
		TagNumber m_Num;
		Any m_Value;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <num:TagNumber>\n"
			  << marge << "   <value:Any>\n"
			  << marge << " }\n";
		}
};

/**
	
*/
typedef TagNumAndValue ReferentialAttribute;

/**
	
*/
typedef TagNumAndValue QuotationVariable;

/**
	
*/
typedef TagNumAndValue QuotationContextFlag;

typedef std::vector<ReferentialAttribute> ListOfReferentialAttribute;

typedef std::vector<QuotationVariable> ListOfQuotationVariable;

typedef std::vector<QuotationContextFlag> ListOfQuotationContextFlag;

/**
	
*/
typedef uint32 FeedOSCmd;

typedef std::vector<FeedOSCmd> ListOfFeedOSCmd;

/**

			a 2-char code for a country -- ISO 3166-1
		
*/
typedef String ISOCountryCode;

/**

			a 2-char code for a language -- ISO 639-1
		
*/
typedef String ISOLanguageCode;

/**

			Market Identifier Code -- ISO 10383 / FIX tag 207
		
*/
typedef String ISOMarketId;

/**

			Classification of Financial Instruments -- ISO 10962 / FIX tag 461
		
*/
typedef String CFICode;

/**
 
*/
typedef uint32 FOSLowLevelVTSTableId;

/**

		
*/
typedef int8 FOSTradingSessionId;

/**
 
*/
typedef uint32 FOSDictionaryEntryId;

/**

			FIX 5.0sp2 FIXML @Urgency
		
*/
typedef FIXMarketNewsUrgency FIXNewsUrgency;

/**
 unique identifier 128 bit long 
*/
class FOSUuid
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_WordA);
			init_feedos_type (m_WordB);
			init_feedos_type (m_WordC);
			init_feedos_type (m_WordD);
		}

		FOSUuid() { reset(); }

		inline FOSUuid(FOSUuid const & c) :
			m_WordA(c.m_WordA),
			m_WordB(c.m_WordB),
			m_WordC(c.m_WordC),
			m_WordD(c.m_WordD)
		{}
		FOSUuid(uint32 worda, uint32 wordb, uint32 wordc, uint32 wordd) :
			m_WordA(worda),
			m_WordB(wordb),
			m_WordC(wordc),
			m_WordD(wordd)
		{}

		FOSUuid const & operator =(FOSUuid const & c)
		{
			m_WordA = c.m_WordA;
			m_WordB = c.m_WordB;
			m_WordC = c.m_WordC;
			m_WordD = c.m_WordD;
			return *this;
		}

		bool operator ==(FOSUuid const & c) const
		{
			return (m_WordA == c.m_WordA) && (m_WordB == c.m_WordB) && (m_WordC == c.m_WordC) && (m_WordD == c.m_WordD);
		}

	public:
		uint32 getWordA() const { return m_WordA; }
		uint32 & getWordA() { return m_WordA; }
		uint32 getWordB() const { return m_WordB; }
		uint32 & getWordB() { return m_WordB; }
		uint32 getWordC() const { return m_WordC; }
		uint32 & getWordC() { return m_WordC; }
		uint32 getWordD() const { return m_WordD; }
		uint32 & getWordD() { return m_WordD; }

	public:
		void setWordA(uint32 worda) { m_WordA = worda; }
		void setWordB(uint32 wordb) { m_WordB = wordb; }
		void setWordC(uint32 wordc) { m_WordC = wordc; }
		void setWordD(uint32 wordd) { m_WordD = wordd; }

	protected:
		uint32 m_WordA;
		uint32 m_WordB;
		uint32 m_WordC;
		uint32 m_WordD;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <worda:uint32>\n"
			  << marge << "   <wordb:uint32>\n"
			  << marge << "   <wordc:uint32>\n"
			  << marge << "   <wordd:uint32>\n"
			  << marge << " }\n";
		}
};

/**

			Buy/Sell side. from FIX 4.4 tag 54
			Buy/Sell side. from FIX 4.4 tag 54
			WARNING: use CHAR values, not INT
			WARNING: added non standard value:	'3'=BuyAndSell
		
*/
typedef char FIXSide;

/**

			The market side of the order imbalance.
			'B' = buy imbalance
			'S' = sell imbalance
			'N' = no imbalance
			'O' = insufficient orders to calculate
		
*/
typedef char ImbalanceSide;

/**

			Trade/Quote scope. from FIX 5.0 tag 546
			WARNING: use CHAR values, not INT
		
*/
typedef char FIXScope;

/**

			an order book line: Ask/Bid price and quantities
			NB: when NbOrders==0  then there is no more order (price and qty are the latest known values)
			NB: when NbOrders==-1 then the number of orders at this price is unknown
		
*/
class OrderBookEntryExt
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
			init_feedos_type (m_NbOrders);
		}

		OrderBookEntryExt() { reset(); }

		inline OrderBookEntryExt(OrderBookEntryExt const & c) :
			m_Price(c.m_Price),
			m_Qty(c.m_Qty),
			m_NbOrders(c.m_NbOrders)
		{}
		OrderBookEntryExt(float64 price, float64 qty, int32 nborders) :
			m_Price(price),
			m_Qty(qty),
			m_NbOrders(nborders)
		{}

		OrderBookEntryExt const & operator =(OrderBookEntryExt const & c)
		{
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			m_NbOrders = c.m_NbOrders;
			return *this;
		}

		bool operator ==(OrderBookEntryExt const & c) const
		{
			return (m_Price == c.m_Price) && (m_Qty == c.m_Qty) && (m_NbOrders == c.m_NbOrders);
		}

	public:
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getQty() const { return m_Qty; }
		float64 & getQty() { return m_Qty; }
		int32 getNbOrders() const { return m_NbOrders; }
		int32 & getNbOrders() { return m_NbOrders; }

	public:
		void setPrice(float64 price) { m_Price = price; }
		void setQty(float64 qty) { m_Qty = qty; }
		void setNbOrders(int32 nborders) { m_NbOrders = nborders; }

	protected:
		float64 m_Price;
		float64 m_Qty;
		int32 m_NbOrders;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <price:float64>\n"
			  << marge << "   <qty:float64>\n"
			  << marge << "   <nborders:int32>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<OrderBookEntryExt> ListOfOrderBookEntryExt;

/**

			an order book line: Ask/Bid price and quantities
		
*/
class OrderBookEntry
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
		}

		OrderBookEntry() { reset(); }

		inline OrderBookEntry(OrderBookEntry const & c) :
			m_Price(c.m_Price),
			m_Qty(c.m_Qty)
		{}
		OrderBookEntry(float64 price, float64 qty) :
			m_Price(price),
			m_Qty(qty)
		{}

		OrderBookEntry const & operator =(OrderBookEntry const & c)
		{
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			return *this;
		}

		bool operator ==(OrderBookEntry const & c) const
		{
			return (m_Price == c.m_Price) && (m_Qty == c.m_Qty);
		}

	public:
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getQty() const { return m_Qty; }
		float64 & getQty() { return m_Qty; }

	public:
		void setPrice(float64 price) { m_Price = price; }
		void setQty(float64 qty) { m_Qty = qty; }

	protected:
		float64 m_Price;
		float64 m_Qty;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <price:float64>\n"
			  << marge << "   <qty:float64>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<OrderBookEntry> ListOfOrderBookEntry;

/**

			bit-wise combinations of (1 SHL X) values, where X belongs to enum QuotationTradeIndicator.
		
*/
typedef uint32 QuotationTradeImpactIndicatorMask;

/**

			bit-wise combinations of (1 SHL X) values, where X belongs to enum QuotationUpdateContent
		
*/
typedef uint32 QuotationContentMask;

/**

			quotation data : instrument trading status AND/OR best limit AND/OR last trade
		
*/
class QuotationTradeEvent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ContentMask);
			init_feedos_type (m_TradingStatus);
			init_feedos_type (m_BestBid);
			init_feedos_type (m_BestAsk);
			init_feedos_type (m_LastTradeQty);
			init_feedos_type (m_Price);
		}

		QuotationTradeEvent() { reset(); }

		inline QuotationTradeEvent(QuotationTradeEvent const & c) :
			m_ContentMask(c.m_ContentMask),
			m_TradingStatus(c.m_TradingStatus),
			m_BestBid(c.m_BestBid),
			m_BestAsk(c.m_BestAsk),
			m_LastTradeQty(c.m_LastTradeQty),
			m_Price(c.m_Price)
		{}
		QuotationTradeEvent(QuotationContentMask contentmask, FIXSecurityTradingStatus tradingstatus, OrderBookEntry const & bestbid, OrderBookEntry const & bestask, float64 lasttradeqty, float64 price) :
			m_ContentMask(contentmask),
			m_TradingStatus(tradingstatus),
			m_BestBid(bestbid),
			m_BestAsk(bestask),
			m_LastTradeQty(lasttradeqty),
			m_Price(price)
		{}

		QuotationTradeEvent const & operator =(QuotationTradeEvent const & c)
		{
			m_ContentMask = c.m_ContentMask;
			m_TradingStatus = c.m_TradingStatus;
			m_BestBid = c.m_BestBid;
			m_BestAsk = c.m_BestAsk;
			m_LastTradeQty = c.m_LastTradeQty;
			m_Price = c.m_Price;
			return *this;
		}

		bool operator ==(QuotationTradeEvent const & c) const
		{
			return (m_ContentMask == c.m_ContentMask) && (m_TradingStatus == c.m_TradingStatus) && (m_BestBid == c.m_BestBid) && (m_BestAsk == c.m_BestAsk) && (m_LastTradeQty == c.m_LastTradeQty) && (m_Price == c.m_Price);
		}

	public:
		QuotationContentMask getContentMask() const { return m_ContentMask; }
		QuotationContentMask & getContentMask() { return m_ContentMask; }
		FIXSecurityTradingStatus getTradingStatus() const { return m_TradingStatus; }
		FIXSecurityTradingStatus & getTradingStatus() { return m_TradingStatus; }
		OrderBookEntry const & getBestBid() const { return m_BestBid; }
		OrderBookEntry & getBestBid() { return m_BestBid; }
		OrderBookEntry const & getBestAsk() const { return m_BestAsk; }
		OrderBookEntry & getBestAsk() { return m_BestAsk; }
		float64 getLastTradeQty() const { return m_LastTradeQty; }
		float64 & getLastTradeQty() { return m_LastTradeQty; }
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }

	public:
		void setContentMask(QuotationContentMask contentmask) { m_ContentMask = contentmask; }
		void setTradingStatus(FIXSecurityTradingStatus tradingstatus) { m_TradingStatus = tradingstatus; }
		void setBestBid(OrderBookEntry const & bestbid) { m_BestBid = bestbid; }
		void setBestAsk(OrderBookEntry const & bestask) { m_BestAsk = bestask; }
		void setLastTradeQty(float64 lasttradeqty) { m_LastTradeQty = lasttradeqty; }
		void setPrice(float64 price) { m_Price = price; }

	protected:
		QuotationContentMask m_ContentMask;
		FIXSecurityTradingStatus m_TradingStatus;
		OrderBookEntry m_BestBid;
		OrderBookEntry m_BestAsk;
		float64 m_LastTradeQty;
		float64 m_Price;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <contentmask:QuotationContentMask>\n"
			  << marge << "   <tradingstatus:FIXSecurityTradingStatus>\n"
			  << marge << "   ";
			OrderBookEntry::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			OrderBookEntry::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <lasttradeqty:float64>\n"
			  << marge << "   <price:float64>\n"
			  << marge << " }\n";
		}
};

/**

			quotation data : instrument trading status AND/OR best limit AND/OR last trade (extended version)
		
*/
class QuotationTradeEventExt
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ContentMask);
			init_feedos_type (m_BestBid);
			init_feedos_type (m_BestAsk);
			init_feedos_type (m_LastTradeQty);
			init_feedos_type (m_Price);
			init_feedos_type (m_Context);
			init_feedos_type (m_Values);
		}

		QuotationTradeEventExt() { reset(); }

		inline QuotationTradeEventExt(QuotationTradeEventExt const & c) :
			m_ContentMask(c.m_ContentMask),
			m_BestBid(c.m_BestBid),
			m_BestAsk(c.m_BestAsk),
			m_LastTradeQty(c.m_LastTradeQty),
			m_Price(c.m_Price),
			m_Context(c.m_Context),
			m_Values(c.m_Values)
		{}
		QuotationTradeEventExt(QuotationContentMask contentmask, OrderBookEntryExt const & bestbid, OrderBookEntryExt const & bestask, float64 lasttradeqty, float64 price, ListOfQuotationContextFlag const & context, ListOfQuotationVariable const & values) :
			m_ContentMask(contentmask),
			m_BestBid(bestbid),
			m_BestAsk(bestask),
			m_LastTradeQty(lasttradeqty),
			m_Price(price),
			m_Context(context),
			m_Values(values)
		{}

		QuotationTradeEventExt const & operator =(QuotationTradeEventExt const & c)
		{
			m_ContentMask = c.m_ContentMask;
			m_BestBid = c.m_BestBid;
			m_BestAsk = c.m_BestAsk;
			m_LastTradeQty = c.m_LastTradeQty;
			m_Price = c.m_Price;
			m_Context = c.m_Context;
			m_Values = c.m_Values;
			return *this;
		}

		bool operator ==(QuotationTradeEventExt const & c) const
		{
			return (m_ContentMask == c.m_ContentMask) && (m_BestBid == c.m_BestBid) && (m_BestAsk == c.m_BestAsk) && (m_LastTradeQty == c.m_LastTradeQty) && (m_Price == c.m_Price) && (m_Context == c.m_Context) && (m_Values == c.m_Values);
		}

	public:
		QuotationContentMask getContentMask() const { return m_ContentMask; }
		QuotationContentMask & getContentMask() { return m_ContentMask; }
		OrderBookEntryExt const & getBestBid() const { return m_BestBid; }
		OrderBookEntryExt & getBestBid() { return m_BestBid; }
		OrderBookEntryExt const & getBestAsk() const { return m_BestAsk; }
		OrderBookEntryExt & getBestAsk() { return m_BestAsk; }
		float64 getLastTradeQty() const { return m_LastTradeQty; }
		float64 & getLastTradeQty() { return m_LastTradeQty; }
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		ListOfQuotationContextFlag const & getContext() const { return m_Context; }
		ListOfQuotationContextFlag & getContext() { return m_Context; }
		ListOfQuotationVariable const & getValues() const { return m_Values; }
		ListOfQuotationVariable & getValues() { return m_Values; }

	public:
		void setContentMask(QuotationContentMask contentmask) { m_ContentMask = contentmask; }
		void setBestBid(OrderBookEntryExt const & bestbid) { m_BestBid = bestbid; }
		void setBestAsk(OrderBookEntryExt const & bestask) { m_BestAsk = bestask; }
		void setLastTradeQty(float64 lasttradeqty) { m_LastTradeQty = lasttradeqty; }
		void setPrice(float64 price) { m_Price = price; }
		void setContext(ListOfQuotationContextFlag const & context) { m_Context = context; }
		inline void swapContext(ListOfQuotationContextFlag & context) { m_Context.swap(context); }
		void setValues(ListOfQuotationVariable const & values) { m_Values = values; }
		inline void swapValues(ListOfQuotationVariable & values) { m_Values.swap(values); }

	protected:
		QuotationContentMask m_ContentMask;
		OrderBookEntryExt m_BestBid;
		OrderBookEntryExt m_BestAsk;
		float64 m_LastTradeQty;
		float64 m_Price;
		ListOfQuotationContextFlag m_Context;
		ListOfQuotationVariable m_Values;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <contentmask:QuotationContentMask>\n"
			  << marge << "   ";
			OrderBookEntryExt::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			OrderBookEntryExt::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <lasttradeqty:float64>\n"
			  << marge << "   <price:float64>\n"
			  << marge << "   ( <context:QuotationContextFlag> )\n"
			  << marge << "   ( <values:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

/**

			quotation data : a bunch of values
		
*/
class QuotationValuesUpdate
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ContentMask);
			init_feedos_type (m_Values);
		}

		QuotationValuesUpdate() { reset(); }

		inline QuotationValuesUpdate(QuotationValuesUpdate const & c) :
			m_ContentMask(c.m_ContentMask),
			m_Values(c.m_Values)
		{}
		QuotationValuesUpdate(QuotationContentMask contentmask, ListOfQuotationVariable const & values) :
			m_ContentMask(contentmask),
			m_Values(values)
		{}

		QuotationValuesUpdate const & operator =(QuotationValuesUpdate const & c)
		{
			m_ContentMask = c.m_ContentMask;
			m_Values = c.m_Values;
			return *this;
		}

		bool operator ==(QuotationValuesUpdate const & c) const
		{
			return (m_ContentMask == c.m_ContentMask) && (m_Values == c.m_Values);
		}

	public:
		QuotationContentMask getContentMask() const { return m_ContentMask; }
		QuotationContentMask & getContentMask() { return m_ContentMask; }
		ListOfQuotationVariable const & getValues() const { return m_Values; }
		ListOfQuotationVariable & getValues() { return m_Values; }

	public:
		void setContentMask(QuotationContentMask contentmask) { m_ContentMask = contentmask; }
		void setValues(ListOfQuotationVariable const & values) { m_Values = values; }
		inline void swapValues(ListOfQuotationVariable & values) { m_Values.swap(values); }

	protected:
		QuotationContentMask m_ContentMask;
		ListOfQuotationVariable m_Values;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <contentmask:QuotationContentMask>\n"
			  << marge << "   ( <values:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

/**

			attributes of a Market Session.
		
*/
class TradingSessionCharacteristics
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_SessionId);
			init_feedos_type (m_TradingSessionId);
			init_feedos_type (m_TradingSessionSubId);
			init_feedos_type (m_TradSesMethod);
			init_feedos_type (m_TradSesMode);
		}

		TradingSessionCharacteristics() { reset(); }

		inline TradingSessionCharacteristics(TradingSessionCharacteristics const & c) :
			m_SessionId(c.m_SessionId),
			m_TradingSessionId(c.m_TradingSessionId),
			m_TradingSessionSubId(c.m_TradingSessionSubId),
			m_TradSesMethod(c.m_TradSesMethod),
			m_TradSesMode(c.m_TradSesMode)
		{}
		TradingSessionCharacteristics(FOSTradingSessionId sessionid, String const & tradingsessionid, String const & tradingsessionsubid, FIXTradSesMethod tradsesmethod, FIXTradSesMode tradsesmode) :
			m_SessionId(sessionid),
			m_TradingSessionId(tradingsessionid),
			m_TradingSessionSubId(tradingsessionsubid),
			m_TradSesMethod(tradsesmethod),
			m_TradSesMode(tradsesmode)
		{}

		TradingSessionCharacteristics const & operator =(TradingSessionCharacteristics const & c)
		{
			m_SessionId = c.m_SessionId;
			m_TradingSessionId = c.m_TradingSessionId;
			m_TradingSessionSubId = c.m_TradingSessionSubId;
			m_TradSesMethod = c.m_TradSesMethod;
			m_TradSesMode = c.m_TradSesMode;
			return *this;
		}

		bool operator ==(TradingSessionCharacteristics const & c) const
		{
			return (m_SessionId == c.m_SessionId) && (m_TradingSessionId == c.m_TradingSessionId) && (m_TradingSessionSubId == c.m_TradingSessionSubId) && (m_TradSesMethod == c.m_TradSesMethod) && (m_TradSesMode == c.m_TradSesMode);
		}

	public:
		FOSTradingSessionId getSessionId() const { return m_SessionId; }
		FOSTradingSessionId & getSessionId() { return m_SessionId; }
		String const & getTradingSessionId() const { return m_TradingSessionId; }
		String & getTradingSessionId() { return m_TradingSessionId; }
		String const & getTradingSessionSubId() const { return m_TradingSessionSubId; }
		String & getTradingSessionSubId() { return m_TradingSessionSubId; }
		FIXTradSesMethod getTradSesMethod() const { return m_TradSesMethod; }
		FIXTradSesMethod & getTradSesMethod() { return m_TradSesMethod; }
		FIXTradSesMode getTradSesMode() const { return m_TradSesMode; }
		FIXTradSesMode & getTradSesMode() { return m_TradSesMode; }

	public:
		void setSessionId(FOSTradingSessionId sessionid) { m_SessionId = sessionid; }
		void setTradingSessionId(String const & tradingsessionid) { m_TradingSessionId = tradingsessionid; }
		void setTradingSessionSubId(String const & tradingsessionsubid) { m_TradingSessionSubId = tradingsessionsubid; }
		void setTradSesMethod(FIXTradSesMethod tradsesmethod) { m_TradSesMethod = tradsesmethod; }
		void setTradSesMode(FIXTradSesMode tradsesmode) { m_TradSesMode = tradsesmode; }

	protected:
		FOSTradingSessionId m_SessionId;
		String m_TradingSessionId;
		String m_TradingSessionSubId;
		FIXTradSesMethod m_TradSesMethod;
		FIXTradSesMode m_TradSesMode;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <sessionid:FOSTradingSessionId>\n"
			  << marge << "   <tradingsessionid:String>\n"
			  << marge << "   <tradingsessionsubid:String>\n"
			  << marge << "   <tradsesmethod:FIXTradSesMethod>\n"
			  << marge << "   <tradsesmode:FIXTradSesMode>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<TradingSessionCharacteristics> ListOfTradingSessionCharacteristics;

/**

			status of a Market Session.
		
*/
class TradingSessionStatus
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_SessionId);
			init_feedos_type (m_TradSesStatusEnum);
			init_feedos_type (m_TradSesStartTime);
			init_feedos_type (m_TradSesOpenTime);
			init_feedos_type (m_TradSesPreCloseTime);
			init_feedos_type (m_TradSesCloseTime);
			init_feedos_type (m_TradSesEndTime);
			init_feedos_type (m_TotalVolumeTraded);
			init_feedos_type (m_LastUpdateTimestamp);
		}

		TradingSessionStatus() { reset(); }

		inline TradingSessionStatus(TradingSessionStatus const & c) :
			m_SessionId(c.m_SessionId),
			m_TradSesStatusEnum(c.m_TradSesStatusEnum),
			m_TradSesStartTime(c.m_TradSesStartTime),
			m_TradSesOpenTime(c.m_TradSesOpenTime),
			m_TradSesPreCloseTime(c.m_TradSesPreCloseTime),
			m_TradSesCloseTime(c.m_TradSesCloseTime),
			m_TradSesEndTime(c.m_TradSesEndTime),
			m_TotalVolumeTraded(c.m_TotalVolumeTraded),
			m_LastUpdateTimestamp(c.m_LastUpdateTimestamp)
		{}
		TradingSessionStatus(FOSTradingSessionId sessionid, FIXTradSesStatus tradsesstatusenum, Timestamp const & tradsesstarttime, Timestamp const & tradsesopentime, Timestamp const & tradsespreclosetime, Timestamp const & tradsesclosetime, Timestamp const & tradsesendtime, float64 totalvolumetraded, Timestamp const & lastupdatetimestamp) :
			m_SessionId(sessionid),
			m_TradSesStatusEnum(tradsesstatusenum),
			m_TradSesStartTime(tradsesstarttime),
			m_TradSesOpenTime(tradsesopentime),
			m_TradSesPreCloseTime(tradsespreclosetime),
			m_TradSesCloseTime(tradsesclosetime),
			m_TradSesEndTime(tradsesendtime),
			m_TotalVolumeTraded(totalvolumetraded),
			m_LastUpdateTimestamp(lastupdatetimestamp)
		{}

		TradingSessionStatus const & operator =(TradingSessionStatus const & c)
		{
			m_SessionId = c.m_SessionId;
			m_TradSesStatusEnum = c.m_TradSesStatusEnum;
			m_TradSesStartTime = c.m_TradSesStartTime;
			m_TradSesOpenTime = c.m_TradSesOpenTime;
			m_TradSesPreCloseTime = c.m_TradSesPreCloseTime;
			m_TradSesCloseTime = c.m_TradSesCloseTime;
			m_TradSesEndTime = c.m_TradSesEndTime;
			m_TotalVolumeTraded = c.m_TotalVolumeTraded;
			m_LastUpdateTimestamp = c.m_LastUpdateTimestamp;
			return *this;
		}

		bool operator ==(TradingSessionStatus const & c) const
		{
			return (m_SessionId == c.m_SessionId) && (m_TradSesStatusEnum == c.m_TradSesStatusEnum) && (m_TradSesStartTime == c.m_TradSesStartTime) && (m_TradSesOpenTime == c.m_TradSesOpenTime) && (m_TradSesPreCloseTime == c.m_TradSesPreCloseTime) && (m_TradSesCloseTime == c.m_TradSesCloseTime) && (m_TradSesEndTime == c.m_TradSesEndTime) && (m_TotalVolumeTraded == c.m_TotalVolumeTraded) && (m_LastUpdateTimestamp == c.m_LastUpdateTimestamp);
		}

	public:
		FOSTradingSessionId getSessionId() const { return m_SessionId; }
		FOSTradingSessionId & getSessionId() { return m_SessionId; }
		FIXTradSesStatus getTradSesStatusEnum() const { return m_TradSesStatusEnum; }
		FIXTradSesStatus & getTradSesStatusEnum() { return m_TradSesStatusEnum; }
		Timestamp const & getTradSesStartTime() const { return m_TradSesStartTime; }
		Timestamp & getTradSesStartTime() { return m_TradSesStartTime; }
		Timestamp const & getTradSesOpenTime() const { return m_TradSesOpenTime; }
		Timestamp & getTradSesOpenTime() { return m_TradSesOpenTime; }
		Timestamp const & getTradSesPreCloseTime() const { return m_TradSesPreCloseTime; }
		Timestamp & getTradSesPreCloseTime() { return m_TradSesPreCloseTime; }
		Timestamp const & getTradSesCloseTime() const { return m_TradSesCloseTime; }
		Timestamp & getTradSesCloseTime() { return m_TradSesCloseTime; }
		Timestamp const & getTradSesEndTime() const { return m_TradSesEndTime; }
		Timestamp & getTradSesEndTime() { return m_TradSesEndTime; }
		float64 getTotalVolumeTraded() const { return m_TotalVolumeTraded; }
		float64 & getTotalVolumeTraded() { return m_TotalVolumeTraded; }
		Timestamp const & getLastUpdateTimestamp() const { return m_LastUpdateTimestamp; }
		Timestamp & getLastUpdateTimestamp() { return m_LastUpdateTimestamp; }

	public:
		void setSessionId(FOSTradingSessionId sessionid) { m_SessionId = sessionid; }
		void setTradSesStatusEnum(FIXTradSesStatus tradsesstatusenum) { m_TradSesStatusEnum = tradsesstatusenum; }
		void setTradSesStartTime(Timestamp const & tradsesstarttime) { m_TradSesStartTime = tradsesstarttime; }
		void setTradSesOpenTime(Timestamp const & tradsesopentime) { m_TradSesOpenTime = tradsesopentime; }
		void setTradSesPreCloseTime(Timestamp const & tradsespreclosetime) { m_TradSesPreCloseTime = tradsespreclosetime; }
		void setTradSesCloseTime(Timestamp const & tradsesclosetime) { m_TradSesCloseTime = tradsesclosetime; }
		void setTradSesEndTime(Timestamp const & tradsesendtime) { m_TradSesEndTime = tradsesendtime; }
		void setTotalVolumeTraded(float64 totalvolumetraded) { m_TotalVolumeTraded = totalvolumetraded; }
		void setLastUpdateTimestamp(Timestamp const & lastupdatetimestamp) { m_LastUpdateTimestamp = lastupdatetimestamp; }

	protected:
		FOSTradingSessionId m_SessionId;
		FIXTradSesStatus m_TradSesStatusEnum;
		Timestamp m_TradSesStartTime;
		Timestamp m_TradSesOpenTime;
		Timestamp m_TradSesPreCloseTime;
		Timestamp m_TradSesCloseTime;
		Timestamp m_TradSesEndTime;
		float64 m_TotalVolumeTraded;
		Timestamp m_LastUpdateTimestamp;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <sessionid:FOSTradingSessionId>\n"
			  << marge << "   <tradsesstatusenum:FIXTradSesStatus>\n"
			  << marge << "   <tradsesstarttime:Timestamp>\n"
			  << marge << "   <tradsesopentime:Timestamp>\n"
			  << marge << "   <tradsespreclosetime:Timestamp>\n"
			  << marge << "   <tradsesclosetime:Timestamp>\n"
			  << marge << "   <tradsesendtime:Timestamp>\n"
			  << marge << "   <totalvolumetraded:float64>\n"
			  << marge << "   <lastupdatetimestamp:Timestamp>\n"
			  << marge << " }\n";
		}
};

/**

			an order book 
		
*/
class OrderBook
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ServerUTCTimestamp);
			init_feedos_type (m_BidLimits);
			init_feedos_type (m_AskLimits);
		}

		OrderBook() { reset(); }

		inline OrderBook(OrderBook const & c) :
			m_ServerUTCTimestamp(c.m_ServerUTCTimestamp),
			m_BidLimits(c.m_BidLimits),
			m_AskLimits(c.m_AskLimits)
		{}
		OrderBook(Timestamp const & serverutctimestamp, ListOfOrderBookEntry const & bidlimits, ListOfOrderBookEntry const & asklimits) :
			m_ServerUTCTimestamp(serverutctimestamp),
			m_BidLimits(bidlimits),
			m_AskLimits(asklimits)
		{}

		OrderBook const & operator =(OrderBook const & c)
		{
			m_ServerUTCTimestamp = c.m_ServerUTCTimestamp;
			m_BidLimits = c.m_BidLimits;
			m_AskLimits = c.m_AskLimits;
			return *this;
		}

		bool operator ==(OrderBook const & c) const
		{
			return (m_ServerUTCTimestamp == c.m_ServerUTCTimestamp) && (m_BidLimits == c.m_BidLimits) && (m_AskLimits == c.m_AskLimits);
		}

	public:
		Timestamp const & getServerUTCTimestamp() const { return m_ServerUTCTimestamp; }
		Timestamp & getServerUTCTimestamp() { return m_ServerUTCTimestamp; }
		ListOfOrderBookEntry const & getBidLimits() const { return m_BidLimits; }
		ListOfOrderBookEntry & getBidLimits() { return m_BidLimits; }
		ListOfOrderBookEntry const & getAskLimits() const { return m_AskLimits; }
		ListOfOrderBookEntry & getAskLimits() { return m_AskLimits; }

	public:
		void setServerUTCTimestamp(Timestamp const & serverutctimestamp) { m_ServerUTCTimestamp = serverutctimestamp; }
		void setBidLimits(ListOfOrderBookEntry const & bidlimits) { m_BidLimits = bidlimits; }
		inline void swapBidLimits(ListOfOrderBookEntry & bidlimits) { m_BidLimits.swap(bidlimits); }
		void setAskLimits(ListOfOrderBookEntry const & asklimits) { m_AskLimits = asklimits; }
		inline void swapAskLimits(ListOfOrderBookEntry & asklimits) { m_AskLimits.swap(asklimits); }

	protected:
		Timestamp m_ServerUTCTimestamp;
		ListOfOrderBookEntry m_BidLimits;
		ListOfOrderBookEntry m_AskLimits;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <serverutctimestamp:Timestamp>\n"
			  << marge << "   ( <bidlimits:OrderBookEntry> )\n";
			OrderBookEntry::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <asklimits:OrderBookEntry> )\n";
			OrderBookEntry::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

/**

			the 1st line of an order book
		
*/
class OrderBookBestLimits
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_BestBid);
			init_feedos_type (m_BestAsk);
		}

		OrderBookBestLimits() { reset(); }

		inline OrderBookBestLimits(OrderBookBestLimits const & c) :
			m_BestBid(c.m_BestBid),
			m_BestAsk(c.m_BestAsk)
		{}
		OrderBookBestLimits(OrderBookEntry const & bestbid, OrderBookEntry const & bestask) :
			m_BestBid(bestbid),
			m_BestAsk(bestask)
		{}

		OrderBookBestLimits const & operator =(OrderBookBestLimits const & c)
		{
			m_BestBid = c.m_BestBid;
			m_BestAsk = c.m_BestAsk;
			return *this;
		}

		bool operator ==(OrderBookBestLimits const & c) const
		{
			return (m_BestBid == c.m_BestBid) && (m_BestAsk == c.m_BestAsk);
		}

	public:
		OrderBookEntry const & getBestBid() const { return m_BestBid; }
		OrderBookEntry & getBestBid() { return m_BestBid; }
		OrderBookEntry const & getBestAsk() const { return m_BestAsk; }
		OrderBookEntry & getBestAsk() { return m_BestAsk; }

	public:
		void setBestBid(OrderBookEntry const & bestbid) { m_BestBid = bestbid; }
		void setBestAsk(OrderBookEntry const & bestask) { m_BestAsk = bestask; }

	protected:
		OrderBookEntry m_BestBid;
		OrderBookEntry m_BestAsk;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			OrderBookEntry::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			OrderBookEntry::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

/**

			the 1st line of an order book
		
*/
class OrderBookBestLimitsExt
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_BestBid);
			init_feedos_type (m_BestAsk);
		}

		OrderBookBestLimitsExt() { reset(); }

		inline OrderBookBestLimitsExt(OrderBookBestLimitsExt const & c) :
			m_BestBid(c.m_BestBid),
			m_BestAsk(c.m_BestAsk)
		{}
		OrderBookBestLimitsExt(OrderBookEntryExt const & bestbid, OrderBookEntryExt const & bestask) :
			m_BestBid(bestbid),
			m_BestAsk(bestask)
		{}

		OrderBookBestLimitsExt const & operator =(OrderBookBestLimitsExt const & c)
		{
			m_BestBid = c.m_BestBid;
			m_BestAsk = c.m_BestAsk;
			return *this;
		}

		bool operator ==(OrderBookBestLimitsExt const & c) const
		{
			return (m_BestBid == c.m_BestBid) && (m_BestAsk == c.m_BestAsk);
		}

	public:
		OrderBookEntryExt const & getBestBid() const { return m_BestBid; }
		OrderBookEntryExt & getBestBid() { return m_BestBid; }
		OrderBookEntryExt const & getBestAsk() const { return m_BestAsk; }
		OrderBookEntryExt & getBestAsk() { return m_BestAsk; }

	public:
		void setBestBid(OrderBookEntryExt const & bestbid) { m_BestBid = bestbid; }
		void setBestAsk(OrderBookEntryExt const & bestask) { m_BestAsk = bestask; }

	protected:
		OrderBookEntryExt m_BestBid;
		OrderBookEntryExt m_BestAsk;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			OrderBookEntryExt::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			OrderBookEntryExt::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

/**

			a delta action to apply on existing orderbook
		
*/
class OrderBookDeltaRefresh
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Action);
			init_feedos_type (m_Level);
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
		}

		OrderBookDeltaRefresh() { reset(); }

		inline OrderBookDeltaRefresh(OrderBookDeltaRefresh const & c) :
			m_Action(c.m_Action),
			m_Level(c.m_Level),
			m_Price(c.m_Price),
			m_Qty(c.m_Qty)
		{}
		OrderBookDeltaRefresh(OrderBookDeltaAction action, int8 level, float64 price, float64 qty) :
			m_Action(action),
			m_Level(level),
			m_Price(price),
			m_Qty(qty)
		{}

		OrderBookDeltaRefresh const & operator =(OrderBookDeltaRefresh const & c)
		{
			m_Action = c.m_Action;
			m_Level = c.m_Level;
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			return *this;
		}

		bool operator ==(OrderBookDeltaRefresh const & c) const
		{
			return (m_Action == c.m_Action) && (m_Level == c.m_Level) && (m_Price == c.m_Price) && (m_Qty == c.m_Qty);
		}

	public:
		OrderBookDeltaAction getAction() const { return m_Action; }
		OrderBookDeltaAction & getAction() { return m_Action; }
		int8 getLevel() const { return m_Level; }
		int8 & getLevel() { return m_Level; }
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getQty() const { return m_Qty; }
		float64 & getQty() { return m_Qty; }

	public:
		void setAction(OrderBookDeltaAction action) { m_Action = action; }
		void setLevel(int8 level) { m_Level = level; }
		void setPrice(float64 price) { m_Price = price; }
		void setQty(float64 qty) { m_Qty = qty; }

	protected:
		OrderBookDeltaAction m_Action;
		int8 m_Level;
		float64 m_Price;
		float64 m_Qty;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <action:OrderBookDeltaAction>\n"
			  << marge << "   <level:int8>\n"
			  << marge << "   <price:float64>\n"
			  << marge << "   <qty:float64>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class UTCTimestamps
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Server);
			init_feedos_type (m_Market);
		}

		UTCTimestamps() { reset(); }

		inline UTCTimestamps(UTCTimestamps const & c) :
			m_Server(c.m_Server),
			m_Market(c.m_Market)
		{}
		UTCTimestamps(Timestamp const & server, Timestamp const & market) :
			m_Server(server),
			m_Market(market)
		{}

		UTCTimestamps const & operator =(UTCTimestamps const & c)
		{
			m_Server = c.m_Server;
			m_Market = c.m_Market;
			return *this;
		}

		bool operator ==(UTCTimestamps const & c) const
		{
			return (m_Server == c.m_Server) && (m_Market == c.m_Market);
		}

	public:
		Timestamp const & getServer() const { return m_Server; }
		Timestamp & getServer() { return m_Server; }
		Timestamp const & getMarket() const { return m_Market; }
		Timestamp & getMarket() { return m_Market; }

	public:
		void setServer(Timestamp const & server) { m_Server = server; }
		void setMarket(Timestamp const & market) { m_Market = market; }

	protected:
		Timestamp m_Server;
		Timestamp m_Market;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <server:Timestamp>\n"
			  << marge << "   <market:Timestamp>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
typedef FOSInteger FOSOrderBookLevel;

/**

		
*/
typedef FOSInteger FOSQty;

/**

		
*/
class MBLQty
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_CumulatedUnits);
			init_feedos_type (m_NbOrders);
		}

		MBLQty() { reset(); }

		inline MBLQty(MBLQty const & c) :
			m_CumulatedUnits(c.m_CumulatedUnits),
			m_NbOrders(c.m_NbOrders)
		{}
		MBLQty(FOSQty const & cumulatedunits, FOSQty const & nborders) :
			m_CumulatedUnits(cumulatedunits),
			m_NbOrders(nborders)
		{}

		MBLQty const & operator =(MBLQty const & c)
		{
			m_CumulatedUnits = c.m_CumulatedUnits;
			m_NbOrders = c.m_NbOrders;
			return *this;
		}

		bool operator ==(MBLQty const & c) const
		{
			return (m_CumulatedUnits == c.m_CumulatedUnits) && (m_NbOrders == c.m_NbOrders);
		}

	public:
		FOSQty const & getCumulatedUnits() const { return m_CumulatedUnits; }
		FOSQty & getCumulatedUnits() { return m_CumulatedUnits; }
		FOSQty const & getNbOrders() const { return m_NbOrders; }
		FOSQty & getNbOrders() { return m_NbOrders; }

	public:
		void setCumulatedUnits(FOSQty const & cumulatedunits) { m_CumulatedUnits = cumulatedunits; }
		void setNbOrders(FOSQty const & nborders) { m_NbOrders = nborders; }

	protected:
		FOSQty m_CumulatedUnits;
		FOSQty m_NbOrders;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <cumulatedunits:FOSQty>\n"
			  << marge << "   <nborders:FOSQty>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class MBLOrderBookEntry
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
		}

		MBLOrderBookEntry() { reset(); }

		inline MBLOrderBookEntry(MBLOrderBookEntry const & c) :
			m_Price(c.m_Price),
			m_Qty(c.m_Qty)
		{}
		MBLOrderBookEntry(FOSPrice const & price, MBLQty const & qty) :
			m_Price(price),
			m_Qty(qty)
		{}

		MBLOrderBookEntry const & operator =(MBLOrderBookEntry const & c)
		{
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			return *this;
		}

		bool operator ==(MBLOrderBookEntry const & c) const
		{
			return (m_Price == c.m_Price) && (m_Qty == c.m_Qty);
		}

	public:
		FOSPrice const & getPrice() const { return m_Price; }
		FOSPrice & getPrice() { return m_Price; }
		MBLQty const & getQty() const { return m_Qty; }
		MBLQty & getQty() { return m_Qty; }

	public:
		void setPrice(FOSPrice const & price) { m_Price = price; }
		void setQty(MBLQty const & qty) { m_Qty = qty; }

	protected:
		FOSPrice m_Price;
		MBLQty m_Qty;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <price:FOSPrice>\n"
			  << marge << "   ";
			MBLQty::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<MBLOrderBookEntry> ListOfMBLOrderBookEntry;

/**

			Internal id of order book.
		
*/
typedef uint32 OrderBookLayerId;

typedef std::vector<OrderBookLayerId> ListOfOrderBookLayerId;

/**

		
*/
class MBLOverlapRefresh
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_LayerId);
			init_feedos_type (m_Timestamps);
			init_feedos_type (m_BidChangeIndicator);
			init_feedos_type (m_AskChangeIndicator);
			init_feedos_type (m_BidLimits);
			init_feedos_type (m_AskLimits);
			init_feedos_type (m_OtherValues);
		}

		MBLOverlapRefresh() { reset(); }

		inline MBLOverlapRefresh(MBLOverlapRefresh const & c) :
			m_Code(c.m_Code),
			m_LayerId(c.m_LayerId),
			m_Timestamps(c.m_Timestamps),
			m_BidChangeIndicator(c.m_BidChangeIndicator),
			m_AskChangeIndicator(c.m_AskChangeIndicator),
			m_BidLimits(c.m_BidLimits),
			m_AskLimits(c.m_AskLimits),
			m_OtherValues(c.m_OtherValues)
		{}
		MBLOverlapRefresh(FOSInstrumentCode code, OrderBookLayerId layerid, UTCTimestamps const & timestamps, FOSInteger const & bidchangeindicator, FOSInteger const & askchangeindicator, ListOfMBLOrderBookEntry const & bidlimits, ListOfMBLOrderBookEntry const & asklimits, ListOfQuotationVariable const & othervalues) :
			m_Code(code),
			m_LayerId(layerid),
			m_Timestamps(timestamps),
			m_BidChangeIndicator(bidchangeindicator),
			m_AskChangeIndicator(askchangeindicator),
			m_BidLimits(bidlimits),
			m_AskLimits(asklimits),
			m_OtherValues(othervalues)
		{}

		MBLOverlapRefresh const & operator =(MBLOverlapRefresh const & c)
		{
			m_Code = c.m_Code;
			m_LayerId = c.m_LayerId;
			m_Timestamps = c.m_Timestamps;
			m_BidChangeIndicator = c.m_BidChangeIndicator;
			m_AskChangeIndicator = c.m_AskChangeIndicator;
			m_BidLimits = c.m_BidLimits;
			m_AskLimits = c.m_AskLimits;
			m_OtherValues = c.m_OtherValues;
			return *this;
		}

		bool operator ==(MBLOverlapRefresh const & c) const
		{
			return (m_Code == c.m_Code) && (m_LayerId == c.m_LayerId) && (m_Timestamps == c.m_Timestamps) && (m_BidChangeIndicator == c.m_BidChangeIndicator) && (m_AskChangeIndicator == c.m_AskChangeIndicator) && (m_BidLimits == c.m_BidLimits) && (m_AskLimits == c.m_AskLimits) && (m_OtherValues == c.m_OtherValues);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		OrderBookLayerId getLayerId() const { return m_LayerId; }
		OrderBookLayerId & getLayerId() { return m_LayerId; }
		UTCTimestamps const & getTimestamps() const { return m_Timestamps; }
		UTCTimestamps & getTimestamps() { return m_Timestamps; }
		FOSInteger const & getBidChangeIndicator() const { return m_BidChangeIndicator; }
		FOSInteger & getBidChangeIndicator() { return m_BidChangeIndicator; }
		FOSInteger const & getAskChangeIndicator() const { return m_AskChangeIndicator; }
		FOSInteger & getAskChangeIndicator() { return m_AskChangeIndicator; }
		ListOfMBLOrderBookEntry const & getBidLimits() const { return m_BidLimits; }
		ListOfMBLOrderBookEntry & getBidLimits() { return m_BidLimits; }
		ListOfMBLOrderBookEntry const & getAskLimits() const { return m_AskLimits; }
		ListOfMBLOrderBookEntry & getAskLimits() { return m_AskLimits; }
		ListOfQuotationVariable const & getOtherValues() const { return m_OtherValues; }
		ListOfQuotationVariable & getOtherValues() { return m_OtherValues; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setLayerId(OrderBookLayerId layerid) { m_LayerId = layerid; }
		void setTimestamps(UTCTimestamps const & timestamps) { m_Timestamps = timestamps; }
		void setBidChangeIndicator(FOSInteger const & bidchangeindicator) { m_BidChangeIndicator = bidchangeindicator; }
		void setAskChangeIndicator(FOSInteger const & askchangeindicator) { m_AskChangeIndicator = askchangeindicator; }
		void setBidLimits(ListOfMBLOrderBookEntry const & bidlimits) { m_BidLimits = bidlimits; }
		inline void swapBidLimits(ListOfMBLOrderBookEntry & bidlimits) { m_BidLimits.swap(bidlimits); }
		void setAskLimits(ListOfMBLOrderBookEntry const & asklimits) { m_AskLimits = asklimits; }
		inline void swapAskLimits(ListOfMBLOrderBookEntry & asklimits) { m_AskLimits.swap(asklimits); }
		void setOtherValues(ListOfQuotationVariable const & othervalues) { m_OtherValues = othervalues; }
		inline void swapOtherValues(ListOfQuotationVariable & othervalues) { m_OtherValues.swap(othervalues); }

	protected:
		FOSInstrumentCode m_Code;
		OrderBookLayerId m_LayerId;
		UTCTimestamps m_Timestamps;
		FOSInteger m_BidChangeIndicator;
		FOSInteger m_AskChangeIndicator;
		ListOfMBLOrderBookEntry m_BidLimits;
		ListOfMBLOrderBookEntry m_AskLimits;
		ListOfQuotationVariable m_OtherValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   <layerid:OrderBookLayerId>\n"
			  << marge << "   ";
			UTCTimestamps::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <bidchangeindicator:FOSInteger>\n"
			  << marge << "   <askchangeindicator:FOSInteger>\n"
			  << marge << "   ( <bidlimits:MBLOrderBookEntry> )\n";
			MBLOrderBookEntry::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <asklimits:MBLOrderBookEntry> )\n";
			MBLOrderBookEntry::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <othervalues:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class MBLDeltaRefresh
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_LayerId);
			init_feedos_type (m_Timestamps);
			init_feedos_type (m_Action);
			init_feedos_type (m_Level);
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
			init_feedos_type (m_ContinuationFlag);
			init_feedos_type (m_OtherValues);
		}

		MBLDeltaRefresh() { reset(); }

		inline MBLDeltaRefresh(MBLDeltaRefresh const & c) :
			m_Code(c.m_Code),
			m_LayerId(c.m_LayerId),
			m_Timestamps(c.m_Timestamps),
			m_Action(c.m_Action),
			m_Level(c.m_Level),
			m_Price(c.m_Price),
			m_Qty(c.m_Qty),
			m_ContinuationFlag(c.m_ContinuationFlag),
			m_OtherValues(c.m_OtherValues)
		{}
		MBLDeltaRefresh(FOSInstrumentCode code, OrderBookLayerId layerid, UTCTimestamps const & timestamps, OrderBookDeltaAction action, FOSOrderBookLevel const & level, FOSPrice const & price, MBLQty const & qty, bool continuationflag, ListOfQuotationVariable const & othervalues) :
			m_Code(code),
			m_LayerId(layerid),
			m_Timestamps(timestamps),
			m_Action(action),
			m_Level(level),
			m_Price(price),
			m_Qty(qty),
			m_ContinuationFlag(continuationflag),
			m_OtherValues(othervalues)
		{}

		MBLDeltaRefresh const & operator =(MBLDeltaRefresh const & c)
		{
			m_Code = c.m_Code;
			m_LayerId = c.m_LayerId;
			m_Timestamps = c.m_Timestamps;
			m_Action = c.m_Action;
			m_Level = c.m_Level;
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			m_ContinuationFlag = c.m_ContinuationFlag;
			m_OtherValues = c.m_OtherValues;
			return *this;
		}

		bool operator ==(MBLDeltaRefresh const & c) const
		{
			return (m_Code == c.m_Code) && (m_LayerId == c.m_LayerId) && (m_Timestamps == c.m_Timestamps) && (m_Action == c.m_Action) && (m_Level == c.m_Level) && (m_Price == c.m_Price) && (m_Qty == c.m_Qty) && (m_ContinuationFlag == c.m_ContinuationFlag) && (m_OtherValues == c.m_OtherValues);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		OrderBookLayerId getLayerId() const { return m_LayerId; }
		OrderBookLayerId & getLayerId() { return m_LayerId; }
		UTCTimestamps const & getTimestamps() const { return m_Timestamps; }
		UTCTimestamps & getTimestamps() { return m_Timestamps; }
		OrderBookDeltaAction getAction() const { return m_Action; }
		OrderBookDeltaAction & getAction() { return m_Action; }
		FOSOrderBookLevel const & getLevel() const { return m_Level; }
		FOSOrderBookLevel & getLevel() { return m_Level; }
		FOSPrice const & getPrice() const { return m_Price; }
		FOSPrice & getPrice() { return m_Price; }
		MBLQty const & getQty() const { return m_Qty; }
		MBLQty & getQty() { return m_Qty; }
		bool getContinuationFlag() const { return m_ContinuationFlag; }
		bool & getContinuationFlag() { return m_ContinuationFlag; }
		ListOfQuotationVariable const & getOtherValues() const { return m_OtherValues; }
		ListOfQuotationVariable & getOtherValues() { return m_OtherValues; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setLayerId(OrderBookLayerId layerid) { m_LayerId = layerid; }
		void setTimestamps(UTCTimestamps const & timestamps) { m_Timestamps = timestamps; }
		void setAction(OrderBookDeltaAction action) { m_Action = action; }
		void setLevel(FOSOrderBookLevel const & level) { m_Level = level; }
		void setPrice(FOSPrice const & price) { m_Price = price; }
		void setQty(MBLQty const & qty) { m_Qty = qty; }
		void setContinuationFlag(bool continuationflag) { m_ContinuationFlag = continuationflag; }
		void setOtherValues(ListOfQuotationVariable const & othervalues) { m_OtherValues = othervalues; }
		inline void swapOtherValues(ListOfQuotationVariable & othervalues) { m_OtherValues.swap(othervalues); }

	protected:
		FOSInstrumentCode m_Code;
		OrderBookLayerId m_LayerId;
		UTCTimestamps m_Timestamps;
		OrderBookDeltaAction m_Action;
		FOSOrderBookLevel m_Level;
		FOSPrice m_Price;
		MBLQty m_Qty;
		bool m_ContinuationFlag;
		ListOfQuotationVariable m_OtherValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   <layerid:OrderBookLayerId>\n"
			  << marge << "   ";
			UTCTimestamps::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <action:OrderBookDeltaAction>\n"
			  << marge << "   <level:FOSOrderBookLevel>\n"
			  << marge << "   <price:FOSPrice>\n"
			  << marge << "   ";
			MBLQty::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <continuationflag:bool>\n"
			  << marge << "   ( <othervalues:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class MBLMaxVisibleDepth
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_LayerId);
			init_feedos_type (m_MaxVisibleDepth);
		}

		MBLMaxVisibleDepth() { reset(); }

		inline MBLMaxVisibleDepth(MBLMaxVisibleDepth const & c) :
			m_Code(c.m_Code),
			m_LayerId(c.m_LayerId),
			m_MaxVisibleDepth(c.m_MaxVisibleDepth)
		{}
		MBLMaxVisibleDepth(FOSInstrumentCode code, OrderBookLayerId layerid, FOSOrderBookLevel const & maxvisibledepth) :
			m_Code(code),
			m_LayerId(layerid),
			m_MaxVisibleDepth(maxvisibledepth)
		{}

		MBLMaxVisibleDepth const & operator =(MBLMaxVisibleDepth const & c)
		{
			m_Code = c.m_Code;
			m_LayerId = c.m_LayerId;
			m_MaxVisibleDepth = c.m_MaxVisibleDepth;
			return *this;
		}

		bool operator ==(MBLMaxVisibleDepth const & c) const
		{
			return (m_Code == c.m_Code) && (m_LayerId == c.m_LayerId) && (m_MaxVisibleDepth == c.m_MaxVisibleDepth);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		OrderBookLayerId getLayerId() const { return m_LayerId; }
		OrderBookLayerId & getLayerId() { return m_LayerId; }
		FOSOrderBookLevel const & getMaxVisibleDepth() const { return m_MaxVisibleDepth; }
		FOSOrderBookLevel & getMaxVisibleDepth() { return m_MaxVisibleDepth; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setLayerId(OrderBookLayerId layerid) { m_LayerId = layerid; }
		void setMaxVisibleDepth(FOSOrderBookLevel const & maxvisibledepth) { m_MaxVisibleDepth = maxvisibledepth; }

	protected:
		FOSInstrumentCode m_Code;
		OrderBookLayerId m_LayerId;
		FOSOrderBookLevel m_MaxVisibleDepth;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   <layerid:OrderBookLayerId>\n"
			  << marge << "   <maxvisibledepth:FOSOrderBookLevel>\n"
			  << marge << " }\n";
		}
};

/**

			an MBL order book 
		
*/
class MBLLayer
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_LayerId);
			init_feedos_type (m_MaxVisibleDepth);
			init_feedos_type (m_Timestamps);
			init_feedos_type (m_BidLimits);
			init_feedos_type (m_AskLimits);
			init_feedos_type (m_OtherValues);
		}

		MBLLayer() { reset(); }

		inline MBLLayer(MBLLayer const & c) :
			m_LayerId(c.m_LayerId),
			m_MaxVisibleDepth(c.m_MaxVisibleDepth),
			m_Timestamps(c.m_Timestamps),
			m_BidLimits(c.m_BidLimits),
			m_AskLimits(c.m_AskLimits),
			m_OtherValues(c.m_OtherValues)
		{}
		MBLLayer(OrderBookLayerId layerid, FOSOrderBookLevel const & maxvisibledepth, UTCTimestamps const & timestamps, ListOfMBLOrderBookEntry const & bidlimits, ListOfMBLOrderBookEntry const & asklimits, ListOfQuotationVariable const & othervalues) :
			m_LayerId(layerid),
			m_MaxVisibleDepth(maxvisibledepth),
			m_Timestamps(timestamps),
			m_BidLimits(bidlimits),
			m_AskLimits(asklimits),
			m_OtherValues(othervalues)
		{}

		MBLLayer const & operator =(MBLLayer const & c)
		{
			m_LayerId = c.m_LayerId;
			m_MaxVisibleDepth = c.m_MaxVisibleDepth;
			m_Timestamps = c.m_Timestamps;
			m_BidLimits = c.m_BidLimits;
			m_AskLimits = c.m_AskLimits;
			m_OtherValues = c.m_OtherValues;
			return *this;
		}

		bool operator ==(MBLLayer const & c) const
		{
			return (m_LayerId == c.m_LayerId) && (m_MaxVisibleDepth == c.m_MaxVisibleDepth) && (m_Timestamps == c.m_Timestamps) && (m_BidLimits == c.m_BidLimits) && (m_AskLimits == c.m_AskLimits) && (m_OtherValues == c.m_OtherValues);
		}

	public:
		OrderBookLayerId getLayerId() const { return m_LayerId; }
		OrderBookLayerId & getLayerId() { return m_LayerId; }
		FOSOrderBookLevel const & getMaxVisibleDepth() const { return m_MaxVisibleDepth; }
		FOSOrderBookLevel & getMaxVisibleDepth() { return m_MaxVisibleDepth; }
		UTCTimestamps const & getTimestamps() const { return m_Timestamps; }
		UTCTimestamps & getTimestamps() { return m_Timestamps; }
		ListOfMBLOrderBookEntry const & getBidLimits() const { return m_BidLimits; }
		ListOfMBLOrderBookEntry & getBidLimits() { return m_BidLimits; }
		ListOfMBLOrderBookEntry const & getAskLimits() const { return m_AskLimits; }
		ListOfMBLOrderBookEntry & getAskLimits() { return m_AskLimits; }
		ListOfQuotationVariable const & getOtherValues() const { return m_OtherValues; }
		ListOfQuotationVariable & getOtherValues() { return m_OtherValues; }

	public:
		void setLayerId(OrderBookLayerId layerid) { m_LayerId = layerid; }
		void setMaxVisibleDepth(FOSOrderBookLevel const & maxvisibledepth) { m_MaxVisibleDepth = maxvisibledepth; }
		void setTimestamps(UTCTimestamps const & timestamps) { m_Timestamps = timestamps; }
		void setBidLimits(ListOfMBLOrderBookEntry const & bidlimits) { m_BidLimits = bidlimits; }
		inline void swapBidLimits(ListOfMBLOrderBookEntry & bidlimits) { m_BidLimits.swap(bidlimits); }
		void setAskLimits(ListOfMBLOrderBookEntry const & asklimits) { m_AskLimits = asklimits; }
		inline void swapAskLimits(ListOfMBLOrderBookEntry & asklimits) { m_AskLimits.swap(asklimits); }
		void setOtherValues(ListOfQuotationVariable const & othervalues) { m_OtherValues = othervalues; }
		inline void swapOtherValues(ListOfQuotationVariable & othervalues) { m_OtherValues.swap(othervalues); }

	protected:
		OrderBookLayerId m_LayerId;
		FOSOrderBookLevel m_MaxVisibleDepth;
		UTCTimestamps m_Timestamps;
		ListOfMBLOrderBookEntry m_BidLimits;
		ListOfMBLOrderBookEntry m_AskLimits;
		ListOfQuotationVariable m_OtherValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <layerid:OrderBookLayerId>\n"
			  << marge << "   <maxvisibledepth:FOSOrderBookLevel>\n"
			  << marge << "   ";
			UTCTimestamps::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ( <bidlimits:MBLOrderBookEntry> )\n";
			MBLOrderBookEntry::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <asklimits:MBLOrderBookEntry> )\n";
			MBLOrderBookEntry::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <othervalues:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<MBLLayer> ListOfMBLLayer;

/**

			a MBL snapshot 
		
*/
class MBLSnapshot
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_Layers);
		}

		MBLSnapshot() { reset(); }

		inline MBLSnapshot(MBLSnapshot const & c) :
			m_Code(c.m_Code),
			m_Layers(c.m_Layers)
		{}
		MBLSnapshot(FOSInstrumentCode code, ListOfMBLLayer const & layers) :
			m_Code(code),
			m_Layers(layers)
		{}

		MBLSnapshot const & operator =(MBLSnapshot const & c)
		{
			m_Code = c.m_Code;
			m_Layers = c.m_Layers;
			return *this;
		}

		bool operator ==(MBLSnapshot const & c) const
		{
			return (m_Code == c.m_Code) && (m_Layers == c.m_Layers);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		ListOfMBLLayer const & getLayers() const { return m_Layers; }
		ListOfMBLLayer & getLayers() { return m_Layers; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setLayers(ListOfMBLLayer const & layers) { m_Layers = layers; }
		inline void swapLayers(ListOfMBLLayer & layers) { m_Layers.swap(layers); }

	protected:
		FOSInstrumentCode m_Code;
		ListOfMBLLayer m_Layers;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   ( <layers:MBLLayer> )\n";
			MBLLayer::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<MBLSnapshot> ListOfMBLSnapshot;

/**

			a Transaction (or new Price information)
		
*/
class TransactionOrPrice
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketUTCTimestamp);
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
		}

		TransactionOrPrice() { reset(); }

		inline TransactionOrPrice(TransactionOrPrice const & c) :
			m_MarketUTCTimestamp(c.m_MarketUTCTimestamp),
			m_Price(c.m_Price),
			m_Qty(c.m_Qty)
		{}
		TransactionOrPrice(Timestamp const & marketutctimestamp, float64 price, float64 qty) :
			m_MarketUTCTimestamp(marketutctimestamp),
			m_Price(price),
			m_Qty(qty)
		{}

		TransactionOrPrice const & operator =(TransactionOrPrice const & c)
		{
			m_MarketUTCTimestamp = c.m_MarketUTCTimestamp;
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			return *this;
		}

		bool operator ==(TransactionOrPrice const & c) const
		{
			return (m_MarketUTCTimestamp == c.m_MarketUTCTimestamp) && (m_Price == c.m_Price) && (m_Qty == c.m_Qty);
		}

	public:
		Timestamp const & getMarketUTCTimestamp() const { return m_MarketUTCTimestamp; }
		Timestamp & getMarketUTCTimestamp() { return m_MarketUTCTimestamp; }
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getQty() const { return m_Qty; }
		float64 & getQty() { return m_Qty; }

	public:
		void setMarketUTCTimestamp(Timestamp const & marketutctimestamp) { m_MarketUTCTimestamp = marketutctimestamp; }
		void setPrice(float64 price) { m_Price = price; }
		void setQty(float64 qty) { m_Qty = qty; }

	protected:
		Timestamp m_MarketUTCTimestamp;
		float64 m_Price;
		float64 m_Qty;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketutctimestamp:Timestamp>\n"
			  << marge << "   <price:float64>\n"
			  << marge << "   <qty:float64>\n"
			  << marge << " }\n";
		}
};

/**

			summary of trades for a session/day (Close set to UNQUOTED at opening)
		
*/
class OHLCTA
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Open);
			init_feedos_type (m_High);
			init_feedos_type (m_Low);
			init_feedos_type (m_Close);
			init_feedos_type (m_VolumeTraded);
			init_feedos_type (m_AssetTraded);
		}

		OHLCTA() { reset(); }

		inline OHLCTA(OHLCTA const & c) :
			m_Open(c.m_Open),
			m_High(c.m_High),
			m_Low(c.m_Low),
			m_Close(c.m_Close),
			m_VolumeTraded(c.m_VolumeTraded),
			m_AssetTraded(c.m_AssetTraded)
		{}
		OHLCTA(float64 open, float64 high, float64 low, float64 close, float64 volumetraded, float64 assettraded) :
			m_Open(open),
			m_High(high),
			m_Low(low),
			m_Close(close),
			m_VolumeTraded(volumetraded),
			m_AssetTraded(assettraded)
		{}

		OHLCTA const & operator =(OHLCTA const & c)
		{
			m_Open = c.m_Open;
			m_High = c.m_High;
			m_Low = c.m_Low;
			m_Close = c.m_Close;
			m_VolumeTraded = c.m_VolumeTraded;
			m_AssetTraded = c.m_AssetTraded;
			return *this;
		}

		bool operator ==(OHLCTA const & c) const
		{
			return (m_Open == c.m_Open) && (m_High == c.m_High) && (m_Low == c.m_Low) && (m_Close == c.m_Close) && (m_VolumeTraded == c.m_VolumeTraded) && (m_AssetTraded == c.m_AssetTraded);
		}

	public:
		float64 getOpen() const { return m_Open; }
		float64 & getOpen() { return m_Open; }
		float64 getHigh() const { return m_High; }
		float64 & getHigh() { return m_High; }
		float64 getLow() const { return m_Low; }
		float64 & getLow() { return m_Low; }
		float64 getClose() const { return m_Close; }
		float64 & getClose() { return m_Close; }
		float64 getVolumeTraded() const { return m_VolumeTraded; }
		float64 & getVolumeTraded() { return m_VolumeTraded; }
		float64 getAssetTraded() const { return m_AssetTraded; }
		float64 & getAssetTraded() { return m_AssetTraded; }

	public:
		void setOpen(float64 open) { m_Open = open; }
		void setHigh(float64 high) { m_High = high; }
		void setLow(float64 low) { m_Low = low; }
		void setClose(float64 close) { m_Close = close; }
		void setVolumeTraded(float64 volumetraded) { m_VolumeTraded = volumetraded; }
		void setAssetTraded(float64 assettraded) { m_AssetTraded = assettraded; }

	protected:
		float64 m_Open;
		float64 m_High;
		float64 m_Low;
		float64 m_Close;
		float64 m_VolumeTraded;
		float64 m_AssetTraded;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <open:float64>\n"
			  << marge << "   <high:float64>\n"
			  << marge << "   <low:float64>\n"
			  << marge << "   <close:float64>\n"
			  << marge << "   <volumetraded:float64>\n"
			  << marge << "   <assettraded:float64>\n"
			  << marge << " }\n";
		}
};

/**

			intraday bar
		
*/
class QuotationIntradayBar
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ServerUTCTimestamp_begin);
			init_feedos_type (m_ServerDuration_seconds);
			init_feedos_type (m_InstrCode);
			init_feedos_type (m_Open);
			init_feedos_type (m_High);
			init_feedos_type (m_Low);
			init_feedos_type (m_Close);
			init_feedos_type (m_VolumeTraded);
			init_feedos_type (m_NbPoints);
			init_feedos_type (m_MarketUTCTimestamp_begin);
			init_feedos_type (m_OtherValues);
		}

		QuotationIntradayBar() { reset(); }

		inline QuotationIntradayBar(QuotationIntradayBar const & c) :
			m_ServerUTCTimestamp_begin(c.m_ServerUTCTimestamp_begin),
			m_ServerDuration_seconds(c.m_ServerDuration_seconds),
			m_InstrCode(c.m_InstrCode),
			m_Open(c.m_Open),
			m_High(c.m_High),
			m_Low(c.m_Low),
			m_Close(c.m_Close),
			m_VolumeTraded(c.m_VolumeTraded),
			m_NbPoints(c.m_NbPoints),
			m_MarketUTCTimestamp_begin(c.m_MarketUTCTimestamp_begin),
			m_OtherValues(c.m_OtherValues)
		{}
		QuotationIntradayBar(Timestamp const & serverutctimestamp_begin, uint16 serverduration_seconds, FOSInstrumentCode instrcode, float64 open, float64 high, float64 low, float64 close, float64 volumetraded, uint32 nbpoints, Timestamp const & marketutctimestamp_begin, ListOfQuotationVariable const & othervalues) :
			m_ServerUTCTimestamp_begin(serverutctimestamp_begin),
			m_ServerDuration_seconds(serverduration_seconds),
			m_InstrCode(instrcode),
			m_Open(open),
			m_High(high),
			m_Low(low),
			m_Close(close),
			m_VolumeTraded(volumetraded),
			m_NbPoints(nbpoints),
			m_MarketUTCTimestamp_begin(marketutctimestamp_begin),
			m_OtherValues(othervalues)
		{}

		QuotationIntradayBar const & operator =(QuotationIntradayBar const & c)
		{
			m_ServerUTCTimestamp_begin = c.m_ServerUTCTimestamp_begin;
			m_ServerDuration_seconds = c.m_ServerDuration_seconds;
			m_InstrCode = c.m_InstrCode;
			m_Open = c.m_Open;
			m_High = c.m_High;
			m_Low = c.m_Low;
			m_Close = c.m_Close;
			m_VolumeTraded = c.m_VolumeTraded;
			m_NbPoints = c.m_NbPoints;
			m_MarketUTCTimestamp_begin = c.m_MarketUTCTimestamp_begin;
			m_OtherValues = c.m_OtherValues;
			return *this;
		}

		bool operator ==(QuotationIntradayBar const & c) const
		{
			return (m_ServerUTCTimestamp_begin == c.m_ServerUTCTimestamp_begin) && (m_ServerDuration_seconds == c.m_ServerDuration_seconds) && (m_InstrCode == c.m_InstrCode) && (m_Open == c.m_Open) && (m_High == c.m_High) && (m_Low == c.m_Low) && (m_Close == c.m_Close) && (m_VolumeTraded == c.m_VolumeTraded) && (m_NbPoints == c.m_NbPoints) && (m_MarketUTCTimestamp_begin == c.m_MarketUTCTimestamp_begin) && (m_OtherValues == c.m_OtherValues);
		}

	public:
		Timestamp const & getServerUTCTimestamp_begin() const { return m_ServerUTCTimestamp_begin; }
		Timestamp & getServerUTCTimestamp_begin() { return m_ServerUTCTimestamp_begin; }
		uint16 getServerDuration_seconds() const { return m_ServerDuration_seconds; }
		uint16 & getServerDuration_seconds() { return m_ServerDuration_seconds; }
		FOSInstrumentCode getInstrCode() const { return m_InstrCode; }
		FOSInstrumentCode & getInstrCode() { return m_InstrCode; }
		float64 getOpen() const { return m_Open; }
		float64 & getOpen() { return m_Open; }
		float64 getHigh() const { return m_High; }
		float64 & getHigh() { return m_High; }
		float64 getLow() const { return m_Low; }
		float64 & getLow() { return m_Low; }
		float64 getClose() const { return m_Close; }
		float64 & getClose() { return m_Close; }
		float64 getVolumeTraded() const { return m_VolumeTraded; }
		float64 & getVolumeTraded() { return m_VolumeTraded; }
		uint32 getNbPoints() const { return m_NbPoints; }
		uint32 & getNbPoints() { return m_NbPoints; }
		Timestamp const & getMarketUTCTimestamp_begin() const { return m_MarketUTCTimestamp_begin; }
		Timestamp & getMarketUTCTimestamp_begin() { return m_MarketUTCTimestamp_begin; }
		ListOfQuotationVariable const & getOtherValues() const { return m_OtherValues; }
		ListOfQuotationVariable & getOtherValues() { return m_OtherValues; }

	public:
		void setServerUTCTimestamp_begin(Timestamp const & serverutctimestamp_begin) { m_ServerUTCTimestamp_begin = serverutctimestamp_begin; }
		void setServerDuration_seconds(uint16 serverduration_seconds) { m_ServerDuration_seconds = serverduration_seconds; }
		void setInstrCode(FOSInstrumentCode instrcode) { m_InstrCode = instrcode; }
		void setOpen(float64 open) { m_Open = open; }
		void setHigh(float64 high) { m_High = high; }
		void setLow(float64 low) { m_Low = low; }
		void setClose(float64 close) { m_Close = close; }
		void setVolumeTraded(float64 volumetraded) { m_VolumeTraded = volumetraded; }
		void setNbPoints(uint32 nbpoints) { m_NbPoints = nbpoints; }
		void setMarketUTCTimestamp_begin(Timestamp const & marketutctimestamp_begin) { m_MarketUTCTimestamp_begin = marketutctimestamp_begin; }
		void setOtherValues(ListOfQuotationVariable const & othervalues) { m_OtherValues = othervalues; }
		inline void swapOtherValues(ListOfQuotationVariable & othervalues) { m_OtherValues.swap(othervalues); }

	protected:
		Timestamp m_ServerUTCTimestamp_begin;
		uint16 m_ServerDuration_seconds;
		FOSInstrumentCode m_InstrCode;
		float64 m_Open;
		float64 m_High;
		float64 m_Low;
		float64 m_Close;
		float64 m_VolumeTraded;
		uint32 m_NbPoints;
		Timestamp m_MarketUTCTimestamp_begin;
		ListOfQuotationVariable m_OtherValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <serverutctimestamp_begin:Timestamp>\n"
			  << marge << "   <serverduration_seconds:uint16>\n"
			  << marge << "   <instrcode:FOSInstrumentCode>\n"
			  << marge << "   <open:float64>\n"
			  << marge << "   <high:float64>\n"
			  << marge << "   <low:float64>\n"
			  << marge << "   <close:float64>\n"
			  << marge << "   <volumetraded:float64>\n"
			  << marge << "   <nbpoints:uint32>\n"
			  << marge << "   <marketutctimestamp_begin:Timestamp>\n"
			  << marge << "   ( <othervalues:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<QuotationIntradayBar> ListOfQuotationIntradayBar;

/**

		
*/
typedef OHLCTA DailyValues;

/**

			a time in hour/minute/second format
		
*/
class HMS_Time
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Hour);
			init_feedos_type (m_Minute);
			init_feedos_type (m_Second);
		}

		HMS_Time() { reset(); }

		inline HMS_Time(HMS_Time const & c) :
			m_Hour(c.m_Hour),
			m_Minute(c.m_Minute),
			m_Second(c.m_Second)
		{}
		HMS_Time(uint8 hour, uint8 minute, uint8 second) :
			m_Hour(hour),
			m_Minute(minute),
			m_Second(second)
		{}

		HMS_Time const & operator =(HMS_Time const & c)
		{
			m_Hour = c.m_Hour;
			m_Minute = c.m_Minute;
			m_Second = c.m_Second;
			return *this;
		}

		bool operator ==(HMS_Time const & c) const
		{
			return (m_Hour == c.m_Hour) && (m_Minute == c.m_Minute) && (m_Second == c.m_Second);
		}

	public:
		uint8 getHour() const { return m_Hour; }
		uint8 & getHour() { return m_Hour; }
		uint8 getMinute() const { return m_Minute; }
		uint8 & getMinute() { return m_Minute; }
		uint8 getSecond() const { return m_Second; }
		uint8 & getSecond() { return m_Second; }

	public:
		void setHour(uint8 hour) { m_Hour = hour; }
		void setMinute(uint8 minute) { m_Minute = minute; }
		void setSecond(uint8 second) { m_Second = second; }

	protected:
		uint8 m_Hour;
		uint8 m_Minute;
		uint8 m_Second;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <hour:uint8>\n"
			  << marge << "   <minute:uint8>\n"
			  << marge << "   <second:uint8>\n"
			  << marge << " }\n";
		}
};

/**

			a date in year/month/day format
		
*/
class YMD_Date
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Year);
			init_feedos_type (m_Month);
			init_feedos_type (m_Day);
		}

		YMD_Date() { reset(); }

		inline YMD_Date(YMD_Date const & c) :
			m_Year(c.m_Year),
			m_Month(c.m_Month),
			m_Day(c.m_Day)
		{}
		YMD_Date(uint16 year, uint8 month, uint8 day) :
			m_Year(year),
			m_Month(month),
			m_Day(day)
		{}

		YMD_Date const & operator =(YMD_Date const & c)
		{
			m_Year = c.m_Year;
			m_Month = c.m_Month;
			m_Day = c.m_Day;
			return *this;
		}

		bool operator ==(YMD_Date const & c) const
		{
			return (m_Year == c.m_Year) && (m_Month == c.m_Month) && (m_Day == c.m_Day);
		}

	public:
		uint16 getYear() const { return m_Year; }
		uint16 & getYear() { return m_Year; }
		uint8 getMonth() const { return m_Month; }
		uint8 & getMonth() { return m_Month; }
		uint8 getDay() const { return m_Day; }
		uint8 & getDay() { return m_Day; }

	public:
		void setYear(uint16 year) { m_Year = year; }
		void setMonth(uint8 month) { m_Month = month; }
		void setDay(uint8 day) { m_Day = day; }

	protected:
		uint16 m_Year;
		uint8 m_Month;
		uint8 m_Day;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <year:uint16>\n"
			  << marge << "   <month:uint8>\n"
			  << marge << "   <day:uint8>\n"
			  << marge << " }\n";
		}
};

/**

			a date (packed version)
		
*/
class YMD_Date_packed
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_DaysSinceEpoch);
		}

		YMD_Date_packed() { reset(); }

		inline YMD_Date_packed(YMD_Date_packed const & c) :
			m_DaysSinceEpoch(c.m_DaysSinceEpoch)
		{}
		YMD_Date_packed(uint16 dayssinceepoch) :
			m_DaysSinceEpoch(dayssinceepoch)
		{}

		YMD_Date_packed const & operator =(YMD_Date_packed const & c)
		{
			m_DaysSinceEpoch = c.m_DaysSinceEpoch;
			return *this;
		}

		bool operator ==(YMD_Date_packed const & c) const
		{
			return (m_DaysSinceEpoch == c.m_DaysSinceEpoch);
		}

	public:
		uint16 getDaysSinceEpoch() const { return m_DaysSinceEpoch; }
		uint16 & getDaysSinceEpoch() { return m_DaysSinceEpoch; }

	public:
		void setDaysSinceEpoch(uint16 dayssinceepoch) { m_DaysSinceEpoch = dayssinceepoch; }

	protected:
		uint16 m_DaysSinceEpoch;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <dayssinceepoch:uint16>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<YMD_Date_packed> ListOfYMD_Date_packed;

/**

			(static) attributes of a Market.
		
*/
class MarketCharacteristics
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketId);
			init_feedos_type (m_MIC);
			init_feedos_type (m_TimeZone);
			init_feedos_type (m_Country);
			init_feedos_type (m_NbMaxInstruments);
			init_feedos_type (m_Sessions);
			init_feedos_type (m_LocalClosedDays);
		}

		MarketCharacteristics() { reset(); }

		inline MarketCharacteristics(MarketCharacteristics const & c) :
			m_MarketId(c.m_MarketId),
			m_MIC(c.m_MIC),
			m_TimeZone(c.m_TimeZone),
			m_Country(c.m_Country),
			m_NbMaxInstruments(c.m_NbMaxInstruments),
			m_Sessions(c.m_Sessions),
			m_LocalClosedDays(c.m_LocalClosedDays)
		{}
		MarketCharacteristics(FOSMarketId marketid, ISOMarketId const & mic, String const & timezone, ISOCountryCode const & country, uint32 nbmaxinstruments, ListOfTradingSessionCharacteristics const & sessions, ListOfYMD_Date_packed const & localcloseddays) :
			m_MarketId(marketid),
			m_MIC(mic),
			m_TimeZone(timezone),
			m_Country(country),
			m_NbMaxInstruments(nbmaxinstruments),
			m_Sessions(sessions),
			m_LocalClosedDays(localcloseddays)
		{}

		MarketCharacteristics const & operator =(MarketCharacteristics const & c)
		{
			m_MarketId = c.m_MarketId;
			m_MIC = c.m_MIC;
			m_TimeZone = c.m_TimeZone;
			m_Country = c.m_Country;
			m_NbMaxInstruments = c.m_NbMaxInstruments;
			m_Sessions = c.m_Sessions;
			m_LocalClosedDays = c.m_LocalClosedDays;
			return *this;
		}

		bool operator ==(MarketCharacteristics const & c) const
		{
			return (m_MarketId == c.m_MarketId) && (m_MIC == c.m_MIC) && (m_TimeZone == c.m_TimeZone) && (m_Country == c.m_Country) && (m_NbMaxInstruments == c.m_NbMaxInstruments) && (m_Sessions == c.m_Sessions) && (m_LocalClosedDays == c.m_LocalClosedDays);
		}

	public:
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		ISOMarketId const & getMIC() const { return m_MIC; }
		ISOMarketId & getMIC() { return m_MIC; }
		String const & getTimeZone() const { return m_TimeZone; }
		String & getTimeZone() { return m_TimeZone; }
		ISOCountryCode const & getCountry() const { return m_Country; }
		ISOCountryCode & getCountry() { return m_Country; }
		uint32 getNbMaxInstruments() const { return m_NbMaxInstruments; }
		uint32 & getNbMaxInstruments() { return m_NbMaxInstruments; }
		ListOfTradingSessionCharacteristics const & getSessions() const { return m_Sessions; }
		ListOfTradingSessionCharacteristics & getSessions() { return m_Sessions; }
		ListOfYMD_Date_packed const & getLocalClosedDays() const { return m_LocalClosedDays; }
		ListOfYMD_Date_packed & getLocalClosedDays() { return m_LocalClosedDays; }

	public:
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setMIC(ISOMarketId const & mic) { m_MIC = mic; }
		void setTimeZone(String const & timezone) { m_TimeZone = timezone; }
		void setCountry(ISOCountryCode const & country) { m_Country = country; }
		void setNbMaxInstruments(uint32 nbmaxinstruments) { m_NbMaxInstruments = nbmaxinstruments; }
		void setSessions(ListOfTradingSessionCharacteristics const & sessions) { m_Sessions = sessions; }
		inline void swapSessions(ListOfTradingSessionCharacteristics & sessions) { m_Sessions.swap(sessions); }
		void setLocalClosedDays(ListOfYMD_Date_packed const & localcloseddays) { m_LocalClosedDays = localcloseddays; }
		inline void swapLocalClosedDays(ListOfYMD_Date_packed & localcloseddays) { m_LocalClosedDays.swap(localcloseddays); }

	protected:
		FOSMarketId m_MarketId;
		ISOMarketId m_MIC;
		String m_TimeZone;
		ISOCountryCode m_Country;
		uint32 m_NbMaxInstruments;
		ListOfTradingSessionCharacteristics m_Sessions;
		ListOfYMD_Date_packed m_LocalClosedDays;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketid:FOSMarketId>\n"
			  << marge << "   <mic:ISOMarketId>\n"
			  << marge << "   <timezone:String>\n"
			  << marge << "   <country:ISOCountryCode>\n"
			  << marge << "   <nbmaxinstruments:uint32>\n"
			  << marge << "   ( <sessions:TradingSessionCharacteristics> )\n";
			TradingSessionCharacteristics::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <localcloseddays:YMD_Date_packed> )\n";
			YMD_Date_packed::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<MarketCharacteristics> ListOfMarketCharacteristics;

/**

			(dynamic) state of a Market.
		
*/
class MarketTimesAndDates
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketUTCTime2MarketLocalTime_minutes);
			init_feedos_type (m_MarketUTCTime2ServerUTCTime_milliseconds);
		}

		MarketTimesAndDates() { reset(); }

		inline MarketTimesAndDates(MarketTimesAndDates const & c) :
			m_MarketUTCTime2MarketLocalTime_minutes(c.m_MarketUTCTime2MarketLocalTime_minutes),
			m_MarketUTCTime2ServerUTCTime_milliseconds(c.m_MarketUTCTime2ServerUTCTime_milliseconds)
		{}
		MarketTimesAndDates(int32 marketutctime2marketlocaltime_minutes, int32 marketutctime2serverutctime_milliseconds) :
			m_MarketUTCTime2MarketLocalTime_minutes(marketutctime2marketlocaltime_minutes),
			m_MarketUTCTime2ServerUTCTime_milliseconds(marketutctime2serverutctime_milliseconds)
		{}

		MarketTimesAndDates const & operator =(MarketTimesAndDates const & c)
		{
			m_MarketUTCTime2MarketLocalTime_minutes = c.m_MarketUTCTime2MarketLocalTime_minutes;
			m_MarketUTCTime2ServerUTCTime_milliseconds = c.m_MarketUTCTime2ServerUTCTime_milliseconds;
			return *this;
		}

		bool operator ==(MarketTimesAndDates const & c) const
		{
			return (m_MarketUTCTime2MarketLocalTime_minutes == c.m_MarketUTCTime2MarketLocalTime_minutes) && (m_MarketUTCTime2ServerUTCTime_milliseconds == c.m_MarketUTCTime2ServerUTCTime_milliseconds);
		}

	public:
		int32 getMarketUTCTime2MarketLocalTime_minutes() const { return m_MarketUTCTime2MarketLocalTime_minutes; }
		int32 & getMarketUTCTime2MarketLocalTime_minutes() { return m_MarketUTCTime2MarketLocalTime_minutes; }
		int32 getMarketUTCTime2ServerUTCTime_milliseconds() const { return m_MarketUTCTime2ServerUTCTime_milliseconds; }
		int32 & getMarketUTCTime2ServerUTCTime_milliseconds() { return m_MarketUTCTime2ServerUTCTime_milliseconds; }

	public:
		void setMarketUTCTime2MarketLocalTime_minutes(int32 marketutctime2marketlocaltime_minutes) { m_MarketUTCTime2MarketLocalTime_minutes = marketutctime2marketlocaltime_minutes; }
		void setMarketUTCTime2ServerUTCTime_milliseconds(int32 marketutctime2serverutctime_milliseconds) { m_MarketUTCTime2ServerUTCTime_milliseconds = marketutctime2serverutctime_milliseconds; }

	protected:
		int32 m_MarketUTCTime2MarketLocalTime_minutes;
		int32 m_MarketUTCTime2ServerUTCTime_milliseconds;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketutctime2marketlocaltime_minutes:int32>\n"
			  << marge << "   <marketutctime2serverutctime_milliseconds:int32>\n"
			  << marge << " }\n";
		}
};

/**

			(dynamic) state of a Market.
		
*/
class MarketStatus
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketId);
			init_feedos_type (m_CurrentSessionStatus);
			init_feedos_type (m_CurrentTimesAndDates);
		}

		MarketStatus() { reset(); }

		inline MarketStatus(MarketStatus const & c) :
			m_MarketId(c.m_MarketId),
			m_CurrentSessionStatus(c.m_CurrentSessionStatus),
			m_CurrentTimesAndDates(c.m_CurrentTimesAndDates)
		{}
		MarketStatus(FOSMarketId marketid, TradingSessionStatus const & currentsessionstatus, MarketTimesAndDates const & currenttimesanddates) :
			m_MarketId(marketid),
			m_CurrentSessionStatus(currentsessionstatus),
			m_CurrentTimesAndDates(currenttimesanddates)
		{}

		MarketStatus const & operator =(MarketStatus const & c)
		{
			m_MarketId = c.m_MarketId;
			m_CurrentSessionStatus = c.m_CurrentSessionStatus;
			m_CurrentTimesAndDates = c.m_CurrentTimesAndDates;
			return *this;
		}

		bool operator ==(MarketStatus const & c) const
		{
			return (m_MarketId == c.m_MarketId) && (m_CurrentSessionStatus == c.m_CurrentSessionStatus) && (m_CurrentTimesAndDates == c.m_CurrentTimesAndDates);
		}

	public:
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		TradingSessionStatus const & getCurrentSessionStatus() const { return m_CurrentSessionStatus; }
		TradingSessionStatus & getCurrentSessionStatus() { return m_CurrentSessionStatus; }
		MarketTimesAndDates const & getCurrentTimesAndDates() const { return m_CurrentTimesAndDates; }
		MarketTimesAndDates & getCurrentTimesAndDates() { return m_CurrentTimesAndDates; }

	public:
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setCurrentSessionStatus(TradingSessionStatus const & currentsessionstatus) { m_CurrentSessionStatus = currentsessionstatus; }
		void setCurrentTimesAndDates(MarketTimesAndDates const & currenttimesanddates) { m_CurrentTimesAndDates = currenttimesanddates; }

	protected:
		FOSMarketId m_MarketId;
		TradingSessionStatus m_CurrentSessionStatus;
		MarketTimesAndDates m_CurrentTimesAndDates;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketid:FOSMarketId>\n"
			  << marge << "   ";
			TradingSessionStatus::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			MarketTimesAndDates::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<MarketStatus> ListOfMarketStatus;

/**

			event/message from the Market.
		
*/
class MarketNews
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_OrigMarketId);
			init_feedos_type (m_OrigUTCTime);
			init_feedos_type (m_Urgency);
			init_feedos_type (m_Headline);
			init_feedos_type (m_URLLink);
			init_feedos_type (m_Content);
			init_feedos_type (m_RelatedInstruments);
		}

		MarketNews() { reset(); }

		inline MarketNews(MarketNews const & c) :
			m_OrigMarketId(c.m_OrigMarketId),
			m_OrigUTCTime(c.m_OrigUTCTime),
			m_Urgency(c.m_Urgency),
			m_Headline(c.m_Headline),
			m_URLLink(c.m_URLLink),
			m_Content(c.m_Content),
			m_RelatedInstruments(c.m_RelatedInstruments)
		{}
		MarketNews(FOSMarketId origmarketid, Timestamp const & origutctime, FIXMarketNewsUrgency urgency, String const & headline, String const & urllink, String const & content, ListOfPolymorphicInstrumentCode const & relatedinstruments) :
			m_OrigMarketId(origmarketid),
			m_OrigUTCTime(origutctime),
			m_Urgency(urgency),
			m_Headline(headline),
			m_URLLink(urllink),
			m_Content(content),
			m_RelatedInstruments(relatedinstruments)
		{}

		MarketNews const & operator =(MarketNews const & c)
		{
			m_OrigMarketId = c.m_OrigMarketId;
			m_OrigUTCTime = c.m_OrigUTCTime;
			m_Urgency = c.m_Urgency;
			m_Headline = c.m_Headline;
			m_URLLink = c.m_URLLink;
			m_Content = c.m_Content;
			m_RelatedInstruments = c.m_RelatedInstruments;
			return *this;
		}

		bool operator ==(MarketNews const & c) const
		{
			return (m_OrigMarketId == c.m_OrigMarketId) && (m_OrigUTCTime == c.m_OrigUTCTime) && (m_Urgency == c.m_Urgency) && (m_Headline == c.m_Headline) && (m_URLLink == c.m_URLLink) && (m_Content == c.m_Content) && (m_RelatedInstruments == c.m_RelatedInstruments);
		}

	public:
		FOSMarketId getOrigMarketId() const { return m_OrigMarketId; }
		FOSMarketId & getOrigMarketId() { return m_OrigMarketId; }
		Timestamp const & getOrigUTCTime() const { return m_OrigUTCTime; }
		Timestamp & getOrigUTCTime() { return m_OrigUTCTime; }
		FIXMarketNewsUrgency getUrgency() const { return m_Urgency; }
		FIXMarketNewsUrgency & getUrgency() { return m_Urgency; }
		String const & getHeadline() const { return m_Headline; }
		String & getHeadline() { return m_Headline; }
		String const & getURLLink() const { return m_URLLink; }
		String & getURLLink() { return m_URLLink; }
		String const & getContent() const { return m_Content; }
		String & getContent() { return m_Content; }
		ListOfPolymorphicInstrumentCode const & getRelatedInstruments() const { return m_RelatedInstruments; }
		ListOfPolymorphicInstrumentCode & getRelatedInstruments() { return m_RelatedInstruments; }

	public:
		void setOrigMarketId(FOSMarketId origmarketid) { m_OrigMarketId = origmarketid; }
		void setOrigUTCTime(Timestamp const & origutctime) { m_OrigUTCTime = origutctime; }
		void setUrgency(FIXMarketNewsUrgency urgency) { m_Urgency = urgency; }
		void setHeadline(String const & headline) { m_Headline = headline; }
		void setURLLink(String const & urllink) { m_URLLink = urllink; }
		void setContent(String const & content) { m_Content = content; }
		void setRelatedInstruments(ListOfPolymorphicInstrumentCode const & relatedinstruments) { m_RelatedInstruments = relatedinstruments; }
		inline void swapRelatedInstruments(ListOfPolymorphicInstrumentCode & relatedinstruments) { m_RelatedInstruments.swap(relatedinstruments); }

	protected:
		FOSMarketId m_OrigMarketId;
		Timestamp m_OrigUTCTime;
		FIXMarketNewsUrgency m_Urgency;
		String m_Headline;
		String m_URLLink;
		String m_Content;
		ListOfPolymorphicInstrumentCode m_RelatedInstruments;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <origmarketid:FOSMarketId>\n"
			  << marge << "   <origutctime:Timestamp>\n"
			  << marge << "   <urgency:FIXMarketNewsUrgency>\n"
			  << marge << "   <headline:String>\n"
			  << marge << "   <urllink:String>\n"
			  << marge << "   <content:String>\n"
			  << marge << "   ( <relatedinstruments:PolymorphicInstrumentCode> )\n"
			  << marge << " }\n";
		}
};

/**

			the number of instruments in a given referential "branch"
		
*/
class MarketBranchId
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketId);
			init_feedos_type (m_SecurityType);
			init_feedos_type (m_CFICode);
		}

		MarketBranchId() { reset(); }

		inline MarketBranchId(MarketBranchId const & c) :
			m_MarketId(c.m_MarketId),
			m_SecurityType(c.m_SecurityType),
			m_CFICode(c.m_CFICode)
		{}
		MarketBranchId(FOSMarketId marketid, String const & securitytype, CFICode const & cficode) :
			m_MarketId(marketid),
			m_SecurityType(securitytype),
			m_CFICode(cficode)
		{}

		MarketBranchId const & operator =(MarketBranchId const & c)
		{
			m_MarketId = c.m_MarketId;
			m_SecurityType = c.m_SecurityType;
			m_CFICode = c.m_CFICode;
			return *this;
		}

		bool operator ==(MarketBranchId const & c) const
		{
			return (m_MarketId == c.m_MarketId) && (m_SecurityType == c.m_SecurityType) && (m_CFICode == c.m_CFICode);
		}

	public:
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		String const & getSecurityType() const { return m_SecurityType; }
		String & getSecurityType() { return m_SecurityType; }
		CFICode const & getCFICode() const { return m_CFICode; }
		CFICode & getCFICode() { return m_CFICode; }

	public:
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setSecurityType(String const & securitytype) { m_SecurityType = securitytype; }
		void setCFICode(CFICode const & cficode) { m_CFICode = cficode; }

	protected:
		FOSMarketId m_MarketId;
		String m_SecurityType;
		CFICode m_CFICode;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketid:FOSMarketId>\n"
			  << marge << "   <securitytype:String>\n"
			  << marge << "   <cficode:CFICode>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<MarketBranchId> ListOfMarketBranchId;

/**

			the number of instruments in a given referential "branch" with entitlement id
		
*/
class EntitledMarketBranchId
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_SourceId);
			init_feedos_type (m_MarketId);
			init_feedos_type (m_SecurityType);
			init_feedos_type (m_CFICode);
			init_feedos_type (m_EntitlementId);
		}

		EntitledMarketBranchId() { reset(); }

		inline EntitledMarketBranchId(EntitledMarketBranchId const & c) :
			m_SourceId(c.m_SourceId),
			m_MarketId(c.m_MarketId),
			m_SecurityType(c.m_SecurityType),
			m_CFICode(c.m_CFICode),
			m_EntitlementId(c.m_EntitlementId)
		{}
		EntitledMarketBranchId(int32 sourceid, FOSMarketId marketid, String const & securitytype, CFICode const & cficode, int32 entitlementid) :
			m_SourceId(sourceid),
			m_MarketId(marketid),
			m_SecurityType(securitytype),
			m_CFICode(cficode),
			m_EntitlementId(entitlementid)
		{}

		EntitledMarketBranchId const & operator =(EntitledMarketBranchId const & c)
		{
			m_SourceId = c.m_SourceId;
			m_MarketId = c.m_MarketId;
			m_SecurityType = c.m_SecurityType;
			m_CFICode = c.m_CFICode;
			m_EntitlementId = c.m_EntitlementId;
			return *this;
		}

		bool operator ==(EntitledMarketBranchId const & c) const
		{
			return (m_SourceId == c.m_SourceId) && (m_MarketId == c.m_MarketId) && (m_SecurityType == c.m_SecurityType) && (m_CFICode == c.m_CFICode) && (m_EntitlementId == c.m_EntitlementId);
		}

	public:
		int32 getSourceId() const { return m_SourceId; }
		int32 & getSourceId() { return m_SourceId; }
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		String const & getSecurityType() const { return m_SecurityType; }
		String & getSecurityType() { return m_SecurityType; }
		CFICode const & getCFICode() const { return m_CFICode; }
		CFICode & getCFICode() { return m_CFICode; }
		int32 getEntitlementId() const { return m_EntitlementId; }
		int32 & getEntitlementId() { return m_EntitlementId; }

	public:
		void setSourceId(int32 sourceid) { m_SourceId = sourceid; }
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setSecurityType(String const & securitytype) { m_SecurityType = securitytype; }
		void setCFICode(CFICode const & cficode) { m_CFICode = cficode; }
		void setEntitlementId(int32 entitlementid) { m_EntitlementId = entitlementid; }

	protected:
		int32 m_SourceId;
		FOSMarketId m_MarketId;
		String m_SecurityType;
		CFICode m_CFICode;
		int32 m_EntitlementId;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <sourceid:int32>\n"
			  << marge << "   <marketid:FOSMarketId>\n"
			  << marge << "   <securitytype:String>\n"
			  << marge << "   <cficode:CFICode>\n"
			  << marge << "   <entitlementid:int32>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<EntitledMarketBranchId> ListOfEntitledMarketBranchId;

/**

			the number of instruments in a given referential "branch" with entitlement id
		
*/
class MarketBranchIdExtended
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketId);
			init_feedos_type (m_SecurityType);
			init_feedos_type (m_CFICode);
			init_feedos_type (m_EntitlementId);
		}

		MarketBranchIdExtended() { reset(); }

		inline MarketBranchIdExtended(MarketBranchIdExtended const & c) :
			m_MarketId(c.m_MarketId),
			m_SecurityType(c.m_SecurityType),
			m_CFICode(c.m_CFICode),
			m_EntitlementId(c.m_EntitlementId)
		{}
		MarketBranchIdExtended(FOSMarketId marketid, String const & securitytype, CFICode const & cficode, int32 entitlementid) :
			m_MarketId(marketid),
			m_SecurityType(securitytype),
			m_CFICode(cficode),
			m_EntitlementId(entitlementid)
		{}

		MarketBranchIdExtended const & operator =(MarketBranchIdExtended const & c)
		{
			m_MarketId = c.m_MarketId;
			m_SecurityType = c.m_SecurityType;
			m_CFICode = c.m_CFICode;
			m_EntitlementId = c.m_EntitlementId;
			return *this;
		}

		bool operator ==(MarketBranchIdExtended const & c) const
		{
			return (m_MarketId == c.m_MarketId) && (m_SecurityType == c.m_SecurityType) && (m_CFICode == c.m_CFICode) && (m_EntitlementId == c.m_EntitlementId);
		}

	public:
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		String const & getSecurityType() const { return m_SecurityType; }
		String & getSecurityType() { return m_SecurityType; }
		CFICode const & getCFICode() const { return m_CFICode; }
		CFICode & getCFICode() { return m_CFICode; }
		int32 getEntitlementId() const { return m_EntitlementId; }
		int32 & getEntitlementId() { return m_EntitlementId; }

	public:
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setSecurityType(String const & securitytype) { m_SecurityType = securitytype; }
		void setCFICode(CFICode const & cficode) { m_CFICode = cficode; }
		void setEntitlementId(int32 entitlementid) { m_EntitlementId = entitlementid; }

	protected:
		FOSMarketId m_MarketId;
		String m_SecurityType;
		CFICode m_CFICode;
		int32 m_EntitlementId;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketid:FOSMarketId>\n"
			  << marge << "   <securitytype:String>\n"
			  << marge << "   <cficode:CFICode>\n"
			  << marge << "   <entitlementid:int32>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<MarketBranchIdExtended> ListOfMarketBranchIdExtended;

/**

			instrument code and its branch
		
*/
class BranchAndInstrument
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Branch);
			init_feedos_type (m_Code);
		}

		BranchAndInstrument() { reset(); }

		inline BranchAndInstrument(BranchAndInstrument const & c) :
			m_Branch(c.m_Branch),
			m_Code(c.m_Code)
		{}
		BranchAndInstrument(EntitledMarketBranchId const & branch, FOSInstrumentCode code) :
			m_Branch(branch),
			m_Code(code)
		{}

		BranchAndInstrument const & operator =(BranchAndInstrument const & c)
		{
			m_Branch = c.m_Branch;
			m_Code = c.m_Code;
			return *this;
		}

		bool operator ==(BranchAndInstrument const & c) const
		{
			return (m_Branch == c.m_Branch) && (m_Code == c.m_Code);
		}

	public:
		EntitledMarketBranchId const & getBranch() const { return m_Branch; }
		EntitledMarketBranchId & getBranch() { return m_Branch; }
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }

	public:
		void setBranch(EntitledMarketBranchId const & branch) { m_Branch = branch; }
		void setCode(FOSInstrumentCode code) { m_Code = code; }

	protected:
		EntitledMarketBranchId m_Branch;
		FOSInstrumentCode m_Code;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			EntitledMarketBranchId::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <code:FOSInstrumentCode>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<BranchAndInstrument> ListOfBranchAndInstrument;

/**

			This class represents the number of instruments in a given referential category.
			It's composed of an instrument category and a quantity.
		
*/
class MarketBranchContent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_BranchId);
			init_feedos_type (m_Quantity);
		}

		MarketBranchContent() { reset(); }

		inline MarketBranchContent(MarketBranchContent const & c) :
			m_BranchId(c.m_BranchId),
			m_Quantity(c.m_Quantity)
		{}
		MarketBranchContent(MarketBranchId const & branchid, uint32 quantity) :
			m_BranchId(branchid),
			m_Quantity(quantity)
		{}

		MarketBranchContent const & operator =(MarketBranchContent const & c)
		{
			m_BranchId = c.m_BranchId;
			m_Quantity = c.m_Quantity;
			return *this;
		}

		bool operator ==(MarketBranchContent const & c) const
		{
			return (m_BranchId == c.m_BranchId) && (m_Quantity == c.m_Quantity);
		}

	public:
		MarketBranchId const & getBranchId() const { return m_BranchId; }
		MarketBranchId & getBranchId() { return m_BranchId; }
		uint32 getQuantity() const { return m_Quantity; }
		uint32 & getQuantity() { return m_Quantity; }

	public:
		void setBranchId(MarketBranchId const & branchid) { m_BranchId = branchid; }
		void setQuantity(uint32 quantity) { m_Quantity = quantity; }

	protected:
		MarketBranchId m_BranchId;
		uint32 m_Quantity;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			MarketBranchId::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <quantity:uint32>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<MarketBranchContent> ListOfMarketBranchContent;

/**

			This class represents the number of instruments in a given referential category.
			It's composed of an instrument category and a quantity.
		
*/
class EntitledMarketBranchContent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_BranchId);
			init_feedos_type (m_Quantity);
		}

		EntitledMarketBranchContent() { reset(); }

		inline EntitledMarketBranchContent(EntitledMarketBranchContent const & c) :
			m_BranchId(c.m_BranchId),
			m_Quantity(c.m_Quantity)
		{}
		EntitledMarketBranchContent(EntitledMarketBranchId const & branchid, uint32 quantity) :
			m_BranchId(branchid),
			m_Quantity(quantity)
		{}

		EntitledMarketBranchContent const & operator =(EntitledMarketBranchContent const & c)
		{
			m_BranchId = c.m_BranchId;
			m_Quantity = c.m_Quantity;
			return *this;
		}

		bool operator ==(EntitledMarketBranchContent const & c) const
		{
			return (m_BranchId == c.m_BranchId) && (m_Quantity == c.m_Quantity);
		}

	public:
		EntitledMarketBranchId const & getBranchId() const { return m_BranchId; }
		EntitledMarketBranchId & getBranchId() { return m_BranchId; }
		uint32 getQuantity() const { return m_Quantity; }
		uint32 & getQuantity() { return m_Quantity; }

	public:
		void setBranchId(EntitledMarketBranchId const & branchid) { m_BranchId = branchid; }
		void setQuantity(uint32 quantity) { m_Quantity = quantity; }

	protected:
		EntitledMarketBranchId m_BranchId;
		uint32 m_Quantity;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			EntitledMarketBranchId::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <quantity:uint32>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<EntitledMarketBranchContent> ListOfEntitledMarketBranchContent;

/**

			Rough content (number and types of instruments) in a Market.
		
*/
class MarketContent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketId);
			init_feedos_type (m_Content);
		}

		MarketContent() { reset(); }

		inline MarketContent(MarketContent const & c) :
			m_MarketId(c.m_MarketId),
			m_Content(c.m_Content)
		{}
		MarketContent(FOSMarketId marketid, ListOfMarketBranchContent const & content) :
			m_MarketId(marketid),
			m_Content(content)
		{}

		MarketContent const & operator =(MarketContent const & c)
		{
			m_MarketId = c.m_MarketId;
			m_Content = c.m_Content;
			return *this;
		}

		bool operator ==(MarketContent const & c) const
		{
			return (m_MarketId == c.m_MarketId) && (m_Content == c.m_Content);
		}

	public:
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		ListOfMarketBranchContent const & getContent() const { return m_Content; }
		ListOfMarketBranchContent & getContent() { return m_Content; }

	public:
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setContent(ListOfMarketBranchContent const & content) { m_Content = content; }
		inline void swapContent(ListOfMarketBranchContent & content) { m_Content.swap(content); }

	protected:
		FOSMarketId m_MarketId;
		ListOfMarketBranchContent m_Content;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketid:FOSMarketId>\n"
			  << marge << "   ( <content:MarketBranchContent> )\n";
			MarketBranchContent::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<MarketContent> ListOfMarketContent;

/**

			Rough content (number and types of instruments) in a Market.
		
*/
class EntitledMarketContent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_MarketId);
			init_feedos_type (m_Content);
		}

		EntitledMarketContent() { reset(); }

		inline EntitledMarketContent(EntitledMarketContent const & c) :
			m_MarketId(c.m_MarketId),
			m_Content(c.m_Content)
		{}
		EntitledMarketContent(FOSMarketId marketid, ListOfEntitledMarketBranchContent const & content) :
			m_MarketId(marketid),
			m_Content(content)
		{}

		EntitledMarketContent const & operator =(EntitledMarketContent const & c)
		{
			m_MarketId = c.m_MarketId;
			m_Content = c.m_Content;
			return *this;
		}

		bool operator ==(EntitledMarketContent const & c) const
		{
			return (m_MarketId == c.m_MarketId) && (m_Content == c.m_Content);
		}

	public:
		FOSMarketId getMarketId() const { return m_MarketId; }
		FOSMarketId & getMarketId() { return m_MarketId; }
		ListOfEntitledMarketBranchContent const & getContent() const { return m_Content; }
		ListOfEntitledMarketBranchContent & getContent() { return m_Content; }

	public:
		void setMarketId(FOSMarketId marketid) { m_MarketId = marketid; }
		void setContent(ListOfEntitledMarketBranchContent const & content) { m_Content = content; }
		inline void swapContent(ListOfEntitledMarketBranchContent & content) { m_Content.swap(content); }

	protected:
		FOSMarketId m_MarketId;
		ListOfEntitledMarketBranchContent m_Content;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <marketid:FOSMarketId>\n"
			  << marge << "   ( <content:EntitledMarketBranchContent> )\n";
			EntitledMarketBranchContent::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<EntitledMarketContent> ListOfEntitledMarketContent;

/**

			instrument (static) attributes
		
*/
class InstrumentCharacteristics
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_Attributes);
		}

		InstrumentCharacteristics() { reset(); }

		inline InstrumentCharacteristics(InstrumentCharacteristics const & c) :
			m_Code(c.m_Code),
			m_Attributes(c.m_Attributes)
		{}
		InstrumentCharacteristics(FOSInstrumentCode code, ListOfReferentialAttribute const & attributes) :
			m_Code(code),
			m_Attributes(attributes)
		{}

		InstrumentCharacteristics const & operator =(InstrumentCharacteristics const & c)
		{
			m_Code = c.m_Code;
			m_Attributes = c.m_Attributes;
			return *this;
		}

		bool operator ==(InstrumentCharacteristics const & c) const
		{
			return (m_Code == c.m_Code) && (m_Attributes == c.m_Attributes);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		ListOfReferentialAttribute const & getAttributes() const { return m_Attributes; }
		ListOfReferentialAttribute & getAttributes() { return m_Attributes; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setAttributes(ListOfReferentialAttribute const & attributes) { m_Attributes = attributes; }
		inline void swapAttributes(ListOfReferentialAttribute & attributes) { m_Attributes.swap(attributes); }

	protected:
		FOSInstrumentCode m_Code;
		ListOfReferentialAttribute m_Attributes;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   ( <attributes:ReferentialAttribute> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<InstrumentCharacteristics> ListOfInstrumentCharacteristics;

/**

			instrument values (price data)
		
*/
class InstrumentStatus
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_Values);
			init_feedos_type (m_OrderBook);
		}

		InstrumentStatus() { reset(); }

		inline InstrumentStatus(InstrumentStatus const & c) :
			m_Code(c.m_Code),
			m_Values(c.m_Values),
			m_OrderBook(c.m_OrderBook)
		{}
		InstrumentStatus(FOSInstrumentCode code, ListOfQuotationVariable const & values, OrderBook const & orderbook) :
			m_Code(code),
			m_Values(values),
			m_OrderBook(orderbook)
		{}

		InstrumentStatus const & operator =(InstrumentStatus const & c)
		{
			m_Code = c.m_Code;
			m_Values = c.m_Values;
			m_OrderBook = c.m_OrderBook;
			return *this;
		}

		bool operator ==(InstrumentStatus const & c) const
		{
			return (m_Code == c.m_Code) && (m_Values == c.m_Values) && (m_OrderBook == c.m_OrderBook);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		ListOfQuotationVariable const & getValues() const { return m_Values; }
		ListOfQuotationVariable & getValues() { return m_Values; }
		OrderBook const & getOrderBook() const { return m_OrderBook; }
		OrderBook & getOrderBook() { return m_OrderBook; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setValues(ListOfQuotationVariable const & values) { m_Values = values; }
		inline void swapValues(ListOfQuotationVariable & values) { m_Values.swap(values); }
		void setOrderBook(OrderBook const & orderbook) { m_OrderBook = orderbook; }

	protected:
		FOSInstrumentCode m_Code;
		ListOfQuotationVariable m_Values;
		OrderBook m_OrderBook;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   ( <values:QuotationVariable> )\n"
			  << marge << "   ";
			OrderBook::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<InstrumentStatus> ListOfInstrumentStatus;

/**

			instrument values (price data)
		
*/
class InstrumentStatusL1
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_Values);
			init_feedos_type (m_BestLimits);
		}

		InstrumentStatusL1() { reset(); }

		inline InstrumentStatusL1(InstrumentStatusL1 const & c) :
			m_Code(c.m_Code),
			m_Values(c.m_Values),
			m_BestLimits(c.m_BestLimits)
		{}
		InstrumentStatusL1(FOSInstrumentCode code, ListOfQuotationVariable const & values, OrderBookBestLimitsExt const & bestlimits) :
			m_Code(code),
			m_Values(values),
			m_BestLimits(bestlimits)
		{}

		InstrumentStatusL1 const & operator =(InstrumentStatusL1 const & c)
		{
			m_Code = c.m_Code;
			m_Values = c.m_Values;
			m_BestLimits = c.m_BestLimits;
			return *this;
		}

		bool operator ==(InstrumentStatusL1 const & c) const
		{
			return (m_Code == c.m_Code) && (m_Values == c.m_Values) && (m_BestLimits == c.m_BestLimits);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		ListOfQuotationVariable const & getValues() const { return m_Values; }
		ListOfQuotationVariable & getValues() { return m_Values; }
		OrderBookBestLimitsExt const & getBestLimits() const { return m_BestLimits; }
		OrderBookBestLimitsExt & getBestLimits() { return m_BestLimits; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setValues(ListOfQuotationVariable const & values) { m_Values = values; }
		inline void swapValues(ListOfQuotationVariable & values) { m_Values.swap(values); }
		void setBestLimits(OrderBookBestLimitsExt const & bestlimits) { m_BestLimits = bestlimits; }

	protected:
		FOSInstrumentCode m_Code;
		ListOfQuotationVariable m_Values;
		OrderBookBestLimitsExt m_BestLimits;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   ( <values:QuotationVariable> )\n"
			  << marge << "   ";
			OrderBookBestLimitsExt::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<InstrumentStatusL1> ListOfInstrumentStatusL1;

/**

			instrument values (price data)
		
*/
class InstrumentStatusL2
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_OrderBook);
		}

		InstrumentStatusL2() { reset(); }

		inline InstrumentStatusL2(InstrumentStatusL2 const & c) :
			m_Code(c.m_Code),
			m_OrderBook(c.m_OrderBook)
		{}
		InstrumentStatusL2(FOSInstrumentCode code, OrderBook const & orderbook) :
			m_Code(code),
			m_OrderBook(orderbook)
		{}

		InstrumentStatusL2 const & operator =(InstrumentStatusL2 const & c)
		{
			m_Code = c.m_Code;
			m_OrderBook = c.m_OrderBook;
			return *this;
		}

		bool operator ==(InstrumentStatusL2 const & c) const
		{
			return (m_Code == c.m_Code) && (m_OrderBook == c.m_OrderBook);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		OrderBook const & getOrderBook() const { return m_OrderBook; }
		OrderBook & getOrderBook() { return m_OrderBook; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setOrderBook(OrderBook const & orderbook) { m_OrderBook = orderbook; }

	protected:
		FOSInstrumentCode m_Code;
		OrderBook m_OrderBook;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   ";
			OrderBook::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<InstrumentStatusL2> ListOfInstrumentStatusL2;

/**

			instrument attributes (static data) and variables (price data)
		
*/
class InstrumentData
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_Attributes);
			init_feedos_type (m_Values);
			init_feedos_type (m_OrderBook);
		}

		InstrumentData() { reset(); }

		inline InstrumentData(InstrumentData const & c) :
			m_Code(c.m_Code),
			m_Attributes(c.m_Attributes),
			m_Values(c.m_Values),
			m_OrderBook(c.m_OrderBook)
		{}
		InstrumentData(FOSInstrumentCode code, ListOfReferentialAttribute const & attributes, ListOfQuotationVariable const & values, OrderBook const & orderbook) :
			m_Code(code),
			m_Attributes(attributes),
			m_Values(values),
			m_OrderBook(orderbook)
		{}

		InstrumentData const & operator =(InstrumentData const & c)
		{
			m_Code = c.m_Code;
			m_Attributes = c.m_Attributes;
			m_Values = c.m_Values;
			m_OrderBook = c.m_OrderBook;
			return *this;
		}

		bool operator ==(InstrumentData const & c) const
		{
			return (m_Code == c.m_Code) && (m_Attributes == c.m_Attributes) && (m_Values == c.m_Values) && (m_OrderBook == c.m_OrderBook);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		ListOfReferentialAttribute const & getAttributes() const { return m_Attributes; }
		ListOfReferentialAttribute & getAttributes() { return m_Attributes; }
		ListOfQuotationVariable const & getValues() const { return m_Values; }
		ListOfQuotationVariable & getValues() { return m_Values; }
		OrderBook const & getOrderBook() const { return m_OrderBook; }
		OrderBook & getOrderBook() { return m_OrderBook; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setAttributes(ListOfReferentialAttribute const & attributes) { m_Attributes = attributes; }
		inline void swapAttributes(ListOfReferentialAttribute & attributes) { m_Attributes.swap(attributes); }
		void setValues(ListOfQuotationVariable const & values) { m_Values = values; }
		inline void swapValues(ListOfQuotationVariable & values) { m_Values.swap(values); }
		void setOrderBook(OrderBook const & orderbook) { m_OrderBook = orderbook; }

	protected:
		FOSInstrumentCode m_Code;
		ListOfReferentialAttribute m_Attributes;
		ListOfQuotationVariable m_Values;
		OrderBook m_OrderBook;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   ( <attributes:ReferentialAttribute> )\n"
			  << marge << "   ( <values:QuotationVariable> )\n"
			  << marge << "   ";
			OrderBook::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<InstrumentData> ListOfInstrumentData;

/**

			SessionNum/Timestamp/Price/Qty
		
*/
class IntradayHistoryPoint
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_SessionId);
			init_feedos_type (m_Trade);
		}

		IntradayHistoryPoint() { reset(); }

		inline IntradayHistoryPoint(IntradayHistoryPoint const & c) :
			m_SessionId(c.m_SessionId),
			m_Trade(c.m_Trade)
		{}
		IntradayHistoryPoint(FOSTradingSessionId sessionid, TransactionOrPrice const & trade) :
			m_SessionId(sessionid),
			m_Trade(trade)
		{}

		IntradayHistoryPoint const & operator =(IntradayHistoryPoint const & c)
		{
			m_SessionId = c.m_SessionId;
			m_Trade = c.m_Trade;
			return *this;
		}

		bool operator ==(IntradayHistoryPoint const & c) const
		{
			return (m_SessionId == c.m_SessionId) && (m_Trade == c.m_Trade);
		}

	public:
		FOSTradingSessionId getSessionId() const { return m_SessionId; }
		FOSTradingSessionId & getSessionId() { return m_SessionId; }
		TransactionOrPrice const & getTrade() const { return m_Trade; }
		TransactionOrPrice & getTrade() { return m_Trade; }

	public:
		void setSessionId(FOSTradingSessionId sessionid) { m_SessionId = sessionid; }
		void setTrade(TransactionOrPrice const & trade) { m_Trade = trade; }

	protected:
		FOSTradingSessionId m_SessionId;
		TransactionOrPrice m_Trade;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <sessionid:FOSTradingSessionId>\n"
			  << marge << "   ";
			TransactionOrPrice::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<IntradayHistoryPoint> ListOfIntradayHistoryPoint;

/**

			Price/Qty/MarketUTCTimestamp/ServerUTCTimestamp/ContentMask/TradeConditionIndex
		
*/
class IntradayHistoryPoint2
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Price);
			init_feedos_type (m_LastTradeQty);
			init_feedos_type (m_MarketUTCTime);
			init_feedos_type (m_ServerUTCTime);
			init_feedos_type (m_ContentMask);
			init_feedos_type (m_TradeConditionIndex);
		}

		IntradayHistoryPoint2() { reset(); }

		inline IntradayHistoryPoint2(IntradayHistoryPoint2 const & c) :
			m_Price(c.m_Price),
			m_LastTradeQty(c.m_LastTradeQty),
			m_MarketUTCTime(c.m_MarketUTCTime),
			m_ServerUTCTime(c.m_ServerUTCTime),
			m_ContentMask(c.m_ContentMask),
			m_TradeConditionIndex(c.m_TradeConditionIndex)
		{}
		IntradayHistoryPoint2(float64 price, float64 lasttradeqty, Timestamp const & marketutctime, Timestamp const & serverutctime, QuotationContentMask contentmask, uint32 tradeconditionindex) :
			m_Price(price),
			m_LastTradeQty(lasttradeqty),
			m_MarketUTCTime(marketutctime),
			m_ServerUTCTime(serverutctime),
			m_ContentMask(contentmask),
			m_TradeConditionIndex(tradeconditionindex)
		{}

		IntradayHistoryPoint2 const & operator =(IntradayHistoryPoint2 const & c)
		{
			m_Price = c.m_Price;
			m_LastTradeQty = c.m_LastTradeQty;
			m_MarketUTCTime = c.m_MarketUTCTime;
			m_ServerUTCTime = c.m_ServerUTCTime;
			m_ContentMask = c.m_ContentMask;
			m_TradeConditionIndex = c.m_TradeConditionIndex;
			return *this;
		}

		bool operator ==(IntradayHistoryPoint2 const & c) const
		{
			return (m_Price == c.m_Price) && (m_LastTradeQty == c.m_LastTradeQty) && (m_MarketUTCTime == c.m_MarketUTCTime) && (m_ServerUTCTime == c.m_ServerUTCTime) && (m_ContentMask == c.m_ContentMask) && (m_TradeConditionIndex == c.m_TradeConditionIndex);
		}

	public:
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getLastTradeQty() const { return m_LastTradeQty; }
		float64 & getLastTradeQty() { return m_LastTradeQty; }
		Timestamp const & getMarketUTCTime() const { return m_MarketUTCTime; }
		Timestamp & getMarketUTCTime() { return m_MarketUTCTime; }
		Timestamp const & getServerUTCTime() const { return m_ServerUTCTime; }
		Timestamp & getServerUTCTime() { return m_ServerUTCTime; }
		QuotationContentMask getContentMask() const { return m_ContentMask; }
		QuotationContentMask & getContentMask() { return m_ContentMask; }
		uint32 getTradeConditionIndex() const { return m_TradeConditionIndex; }
		uint32 & getTradeConditionIndex() { return m_TradeConditionIndex; }

	public:
		void setPrice(float64 price) { m_Price = price; }
		void setLastTradeQty(float64 lasttradeqty) { m_LastTradeQty = lasttradeqty; }
		void setMarketUTCTime(Timestamp const & marketutctime) { m_MarketUTCTime = marketutctime; }
		void setServerUTCTime(Timestamp const & serverutctime) { m_ServerUTCTime = serverutctime; }
		void setContentMask(QuotationContentMask contentmask) { m_ContentMask = contentmask; }
		void setTradeConditionIndex(uint32 tradeconditionindex) { m_TradeConditionIndex = tradeconditionindex; }

	protected:
		float64 m_Price;
		float64 m_LastTradeQty;
		Timestamp m_MarketUTCTime;
		Timestamp m_ServerUTCTime;
		QuotationContentMask m_ContentMask;
		uint32 m_TradeConditionIndex;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <price:float64>\n"
			  << marge << "   <lasttradeqty:float64>\n"
			  << marge << "   <marketutctime:Timestamp>\n"
			  << marge << "   <serverutctime:Timestamp>\n"
			  << marge << "   <contentmask:QuotationContentMask>\n"
			  << marge << "   <tradeconditionindex:uint32>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<IntradayHistoryPoint2> ListOfIntradayHistoryPoint2;

/**

			Price/Qty/MarketUTCTimestamp/ServerUTCTimestamp/ContentMask/TradeConditionIndex/TradeProperties
		
*/
class IntradayHistoryPointExtended
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Price);
			init_feedos_type (m_LastTradeQty);
			init_feedos_type (m_MarketUTCTimestamp);
			init_feedos_type (m_ServerUTCTimestamp);
			init_feedos_type (m_ContentMask);
			init_feedos_type (m_TradeConditionIndex);
			init_feedos_type (m_Properties);
		}

		IntradayHistoryPointExtended() { reset(); }

		inline IntradayHistoryPointExtended(IntradayHistoryPointExtended const & c) :
			m_Price(c.m_Price),
			m_LastTradeQty(c.m_LastTradeQty),
			m_MarketUTCTimestamp(c.m_MarketUTCTimestamp),
			m_ServerUTCTimestamp(c.m_ServerUTCTimestamp),
			m_ContentMask(c.m_ContentMask),
			m_TradeConditionIndex(c.m_TradeConditionIndex),
			m_Properties(c.m_Properties)
		{}
		IntradayHistoryPointExtended(float64 price, float64 lasttradeqty, Timestamp const & marketutctimestamp, Timestamp const & serverutctimestamp, QuotationContentMask contentmask, uint32 tradeconditionindex, ListOfQuotationVariable const & properties) :
			m_Price(price),
			m_LastTradeQty(lasttradeqty),
			m_MarketUTCTimestamp(marketutctimestamp),
			m_ServerUTCTimestamp(serverutctimestamp),
			m_ContentMask(contentmask),
			m_TradeConditionIndex(tradeconditionindex),
			m_Properties(properties)
		{}

		IntradayHistoryPointExtended const & operator =(IntradayHistoryPointExtended const & c)
		{
			m_Price = c.m_Price;
			m_LastTradeQty = c.m_LastTradeQty;
			m_MarketUTCTimestamp = c.m_MarketUTCTimestamp;
			m_ServerUTCTimestamp = c.m_ServerUTCTimestamp;
			m_ContentMask = c.m_ContentMask;
			m_TradeConditionIndex = c.m_TradeConditionIndex;
			m_Properties = c.m_Properties;
			return *this;
		}

		bool operator ==(IntradayHistoryPointExtended const & c) const
		{
			return (m_Price == c.m_Price) && (m_LastTradeQty == c.m_LastTradeQty) && (m_MarketUTCTimestamp == c.m_MarketUTCTimestamp) && (m_ServerUTCTimestamp == c.m_ServerUTCTimestamp) && (m_ContentMask == c.m_ContentMask) && (m_TradeConditionIndex == c.m_TradeConditionIndex) && (m_Properties == c.m_Properties);
		}

	public:
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getLastTradeQty() const { return m_LastTradeQty; }
		float64 & getLastTradeQty() { return m_LastTradeQty; }
		Timestamp const & getMarketUTCTimestamp() const { return m_MarketUTCTimestamp; }
		Timestamp & getMarketUTCTimestamp() { return m_MarketUTCTimestamp; }
		Timestamp const & getServerUTCTimestamp() const { return m_ServerUTCTimestamp; }
		Timestamp & getServerUTCTimestamp() { return m_ServerUTCTimestamp; }
		QuotationContentMask getContentMask() const { return m_ContentMask; }
		QuotationContentMask & getContentMask() { return m_ContentMask; }
		uint32 getTradeConditionIndex() const { return m_TradeConditionIndex; }
		uint32 & getTradeConditionIndex() { return m_TradeConditionIndex; }
		ListOfQuotationVariable const & getProperties() const { return m_Properties; }
		ListOfQuotationVariable & getProperties() { return m_Properties; }

	public:
		void setPrice(float64 price) { m_Price = price; }
		void setLastTradeQty(float64 lasttradeqty) { m_LastTradeQty = lasttradeqty; }
		void setMarketUTCTimestamp(Timestamp const & marketutctimestamp) { m_MarketUTCTimestamp = marketutctimestamp; }
		void setServerUTCTimestamp(Timestamp const & serverutctimestamp) { m_ServerUTCTimestamp = serverutctimestamp; }
		void setContentMask(QuotationContentMask contentmask) { m_ContentMask = contentmask; }
		void setTradeConditionIndex(uint32 tradeconditionindex) { m_TradeConditionIndex = tradeconditionindex; }
		void setProperties(ListOfQuotationVariable const & properties) { m_Properties = properties; }
		inline void swapProperties(ListOfQuotationVariable & properties) { m_Properties.swap(properties); }

	protected:
		float64 m_Price;
		float64 m_LastTradeQty;
		Timestamp m_MarketUTCTimestamp;
		Timestamp m_ServerUTCTimestamp;
		QuotationContentMask m_ContentMask;
		uint32 m_TradeConditionIndex;
		ListOfQuotationVariable m_Properties;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <price:float64>\n"
			  << marge << "   <lasttradeqty:float64>\n"
			  << marge << "   <marketutctimestamp:Timestamp>\n"
			  << marge << "   <serverutctimestamp:Timestamp>\n"
			  << marge << "   <contentmask:QuotationContentMask>\n"
			  << marge << "   <tradeconditionindex:uint32>\n"
			  << marge << "   ( <properties:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<IntradayHistoryPointExtended> ListOfIntradayHistoryPointExtended;

/**

			Date/Open/High/Low/Close/CumVol/Asset
		
*/
class DailyHistoryPoint
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_LocalDate);
			init_feedos_type (m_Values);
		}

		DailyHistoryPoint() { reset(); }

		inline DailyHistoryPoint(DailyHistoryPoint const & c) :
			m_LocalDate(c.m_LocalDate),
			m_Values(c.m_Values)
		{}
		DailyHistoryPoint(YMD_Date_packed const & localdate, DailyValues const & values) :
			m_LocalDate(localdate),
			m_Values(values)
		{}

		DailyHistoryPoint const & operator =(DailyHistoryPoint const & c)
		{
			m_LocalDate = c.m_LocalDate;
			m_Values = c.m_Values;
			return *this;
		}

		bool operator ==(DailyHistoryPoint const & c) const
		{
			return (m_LocalDate == c.m_LocalDate) && (m_Values == c.m_Values);
		}

	public:
		YMD_Date_packed const & getLocalDate() const { return m_LocalDate; }
		YMD_Date_packed & getLocalDate() { return m_LocalDate; }
		DailyValues const & getValues() const { return m_Values; }
		DailyValues & getValues() { return m_Values; }

	public:
		void setLocalDate(YMD_Date_packed const & localdate) { m_LocalDate = localdate; }
		void setValues(DailyValues const & values) { m_Values = values; }

	protected:
		YMD_Date_packed m_LocalDate;
		DailyValues m_Values;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			YMD_Date_packed::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			OHLCTA::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<DailyHistoryPoint> ListOfDailyHistoryPoint;

/**

			Date(YMD)/SessionId/Open/High/Low/Close/Vol/Asset
		
*/
class DailyHistoryPointExt
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Date);
			init_feedos_type (m_TradingSessionId);
			init_feedos_type (m_Open);
			init_feedos_type (m_High);
			init_feedos_type (m_Low);
			init_feedos_type (m_Close);
			init_feedos_type (m_VolumeTraded);
			init_feedos_type (m_AssetTraded);
			init_feedos_type (m_OtherValues);
		}

		DailyHistoryPointExt() { reset(); }

		inline DailyHistoryPointExt(DailyHistoryPointExt const & c) :
			m_Date(c.m_Date),
			m_TradingSessionId(c.m_TradingSessionId),
			m_Open(c.m_Open),
			m_High(c.m_High),
			m_Low(c.m_Low),
			m_Close(c.m_Close),
			m_VolumeTraded(c.m_VolumeTraded),
			m_AssetTraded(c.m_AssetTraded),
			m_OtherValues(c.m_OtherValues)
		{}
		DailyHistoryPointExt(YMD_Date_packed const & date, FOSTradingSessionId tradingsessionid, float64 open, float64 high, float64 low, float64 close, float64 volumetraded, float64 assettraded, ListOfQuotationVariable const & othervalues) :
			m_Date(date),
			m_TradingSessionId(tradingsessionid),
			m_Open(open),
			m_High(high),
			m_Low(low),
			m_Close(close),
			m_VolumeTraded(volumetraded),
			m_AssetTraded(assettraded),
			m_OtherValues(othervalues)
		{}

		DailyHistoryPointExt const & operator =(DailyHistoryPointExt const & c)
		{
			m_Date = c.m_Date;
			m_TradingSessionId = c.m_TradingSessionId;
			m_Open = c.m_Open;
			m_High = c.m_High;
			m_Low = c.m_Low;
			m_Close = c.m_Close;
			m_VolumeTraded = c.m_VolumeTraded;
			m_AssetTraded = c.m_AssetTraded;
			m_OtherValues = c.m_OtherValues;
			return *this;
		}

		bool operator ==(DailyHistoryPointExt const & c) const
		{
			return (m_Date == c.m_Date) && (m_TradingSessionId == c.m_TradingSessionId) && (m_Open == c.m_Open) && (m_High == c.m_High) && (m_Low == c.m_Low) && (m_Close == c.m_Close) && (m_VolumeTraded == c.m_VolumeTraded) && (m_AssetTraded == c.m_AssetTraded) && (m_OtherValues == c.m_OtherValues);
		}

	public:
		YMD_Date_packed const & getDate() const { return m_Date; }
		YMD_Date_packed & getDate() { return m_Date; }
		FOSTradingSessionId getTradingSessionId() const { return m_TradingSessionId; }
		FOSTradingSessionId & getTradingSessionId() { return m_TradingSessionId; }
		float64 getOpen() const { return m_Open; }
		float64 & getOpen() { return m_Open; }
		float64 getHigh() const { return m_High; }
		float64 & getHigh() { return m_High; }
		float64 getLow() const { return m_Low; }
		float64 & getLow() { return m_Low; }
		float64 getClose() const { return m_Close; }
		float64 & getClose() { return m_Close; }
		float64 getVolumeTraded() const { return m_VolumeTraded; }
		float64 & getVolumeTraded() { return m_VolumeTraded; }
		float64 getAssetTraded() const { return m_AssetTraded; }
		float64 & getAssetTraded() { return m_AssetTraded; }
		ListOfQuotationVariable const & getOtherValues() const { return m_OtherValues; }
		ListOfQuotationVariable & getOtherValues() { return m_OtherValues; }

	public:
		void setDate(YMD_Date_packed const & date) { m_Date = date; }
		void setTradingSessionId(FOSTradingSessionId tradingsessionid) { m_TradingSessionId = tradingsessionid; }
		void setOpen(float64 open) { m_Open = open; }
		void setHigh(float64 high) { m_High = high; }
		void setLow(float64 low) { m_Low = low; }
		void setClose(float64 close) { m_Close = close; }
		void setVolumeTraded(float64 volumetraded) { m_VolumeTraded = volumetraded; }
		void setAssetTraded(float64 assettraded) { m_AssetTraded = assettraded; }
		void setOtherValues(ListOfQuotationVariable const & othervalues) { m_OtherValues = othervalues; }
		inline void swapOtherValues(ListOfQuotationVariable & othervalues) { m_OtherValues.swap(othervalues); }

	protected:
		YMD_Date_packed m_Date;
		FOSTradingSessionId m_TradingSessionId;
		float64 m_Open;
		float64 m_High;
		float64 m_Low;
		float64 m_Close;
		float64 m_VolumeTraded;
		float64 m_AssetTraded;
		ListOfQuotationVariable m_OtherValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			YMD_Date_packed::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <tradingsessionid:FOSTradingSessionId>\n"
			  << marge << "   <open:float64>\n"
			  << marge << "   <high:float64>\n"
			  << marge << "   <low:float64>\n"
			  << marge << "   <close:float64>\n"
			  << marge << "   <volumetraded:float64>\n"
			  << marge << "   <assettraded:float64>\n"
			  << marge << "   ( <othervalues:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<DailyHistoryPointExt> ListOfDailyHistoryPointExt;

/**

			A set of TradeConditions identified by its id.
		
*/
class TradeConditionsDictionaryEntry
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Index);
			init_feedos_type (m_Value);
		}

		TradeConditionsDictionaryEntry() { reset(); }

		inline TradeConditionsDictionaryEntry(TradeConditionsDictionaryEntry const & c) :
			m_Index(c.m_Index),
			m_Value(c.m_Value)
		{}
		TradeConditionsDictionaryEntry(uint32 index, ListOfQuotationContextFlag const & value) :
			m_Index(index),
			m_Value(value)
		{}

		TradeConditionsDictionaryEntry const & operator =(TradeConditionsDictionaryEntry const & c)
		{
			m_Index = c.m_Index;
			m_Value = c.m_Value;
			return *this;
		}

		bool operator ==(TradeConditionsDictionaryEntry const & c) const
		{
			return (m_Index == c.m_Index) && (m_Value == c.m_Value);
		}

	public:
		uint32 getIndex() const { return m_Index; }
		uint32 & getIndex() { return m_Index; }
		ListOfQuotationContextFlag const & getValue() const { return m_Value; }
		ListOfQuotationContextFlag & getValue() { return m_Value; }

	public:
		void setIndex(uint32 index) { m_Index = index; }
		void setValue(ListOfQuotationContextFlag const & value) { m_Value = value; }
		inline void swapValue(ListOfQuotationContextFlag & value) { m_Value.swap(value); }

	protected:
		uint32 m_Index;
		ListOfQuotationContextFlag m_Value;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <index:uint32>\n"
			  << marge << "   ( <value:QuotationContextFlag> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<TradeConditionsDictionaryEntry> ListOfTradeConditionsDictionaryEntry;

/**

			A band of price with corresponding 'tick size'
		
*/
class VariableIncrementPriceBand
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Inclusive);
			init_feedos_type (m_LowerBoundary);
			init_feedos_type (m_PriceIncrement);
		}

		VariableIncrementPriceBand() { reset(); }

		inline VariableIncrementPriceBand(VariableIncrementPriceBand const & c) :
			m_Inclusive(c.m_Inclusive),
			m_LowerBoundary(c.m_LowerBoundary),
			m_PriceIncrement(c.m_PriceIncrement)
		{}
		VariableIncrementPriceBand(bool inclusive, float64 lowerboundary, float64 priceincrement) :
			m_Inclusive(inclusive),
			m_LowerBoundary(lowerboundary),
			m_PriceIncrement(priceincrement)
		{}

		VariableIncrementPriceBand const & operator =(VariableIncrementPriceBand const & c)
		{
			m_Inclusive = c.m_Inclusive;
			m_LowerBoundary = c.m_LowerBoundary;
			m_PriceIncrement = c.m_PriceIncrement;
			return *this;
		}

		bool operator ==(VariableIncrementPriceBand const & c) const
		{
			return (m_Inclusive == c.m_Inclusive) && (m_LowerBoundary == c.m_LowerBoundary) && (m_PriceIncrement == c.m_PriceIncrement);
		}

	public:
		bool getInclusive() const { return m_Inclusive; }
		bool & getInclusive() { return m_Inclusive; }
		float64 getLowerBoundary() const { return m_LowerBoundary; }
		float64 & getLowerBoundary() { return m_LowerBoundary; }
		float64 getPriceIncrement() const { return m_PriceIncrement; }
		float64 & getPriceIncrement() { return m_PriceIncrement; }

	public:
		void setInclusive(bool inclusive) { m_Inclusive = inclusive; }
		void setLowerBoundary(float64 lowerboundary) { m_LowerBoundary = lowerboundary; }
		void setPriceIncrement(float64 priceincrement) { m_PriceIncrement = priceincrement; }

	protected:
		bool m_Inclusive;
		float64 m_LowerBoundary;
		float64 m_PriceIncrement;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <inclusive:bool>\n"
			  << marge << "   <lowerboundary:float64>\n"
			  << marge << "   <priceincrement:float64>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<VariableIncrementPriceBand> ListOfVariableIncrementPriceBand;

/**

			Table describing variable tick size
		
*/
class VariableIncrementPriceBandTable
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_TableId);
			init_feedos_type (m_Description);
			init_feedos_type (m_PriceBands);
		}

		VariableIncrementPriceBandTable() { reset(); }

		inline VariableIncrementPriceBandTable(VariableIncrementPriceBandTable const & c) :
			m_TableId(c.m_TableId),
			m_Description(c.m_Description),
			m_PriceBands(c.m_PriceBands)
		{}
		VariableIncrementPriceBandTable(uint32 tableid, String const & description, ListOfVariableIncrementPriceBand const & pricebands) :
			m_TableId(tableid),
			m_Description(description),
			m_PriceBands(pricebands)
		{}

		VariableIncrementPriceBandTable const & operator =(VariableIncrementPriceBandTable const & c)
		{
			m_TableId = c.m_TableId;
			m_Description = c.m_Description;
			m_PriceBands = c.m_PriceBands;
			return *this;
		}

		bool operator ==(VariableIncrementPriceBandTable const & c) const
		{
			return (m_TableId == c.m_TableId) && (m_Description == c.m_Description) && (m_PriceBands == c.m_PriceBands);
		}

	public:
		uint32 getTableId() const { return m_TableId; }
		uint32 & getTableId() { return m_TableId; }
		String const & getDescription() const { return m_Description; }
		String & getDescription() { return m_Description; }
		ListOfVariableIncrementPriceBand const & getPriceBands() const { return m_PriceBands; }
		ListOfVariableIncrementPriceBand & getPriceBands() { return m_PriceBands; }

	public:
		void setTableId(uint32 tableid) { m_TableId = tableid; }
		void setDescription(String const & description) { m_Description = description; }
		void setPriceBands(ListOfVariableIncrementPriceBand const & pricebands) { m_PriceBands = pricebands; }
		inline void swapPriceBands(ListOfVariableIncrementPriceBand & pricebands) { m_PriceBands.swap(pricebands); }

	protected:
		uint32 m_TableId;
		String m_Description;
		ListOfVariableIncrementPriceBand m_PriceBands;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <tableid:uint32>\n"
			  << marge << "   <description:String>\n"
			  << marge << "   ( <pricebands:VariableIncrementPriceBand> )\n";
			VariableIncrementPriceBand::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<VariableIncrementPriceBandTable> ListOfVariableIncrementPriceBandTable;

typedef String NewsHeadline;

typedef String NewsKeyword;

typedef String NewsSubmitter;

typedef std::vector<NewsKeyword> ListOfNewsKeyword;

typedef String CompanyId;

typedef std::vector<CompanyId> ListOfCompanyId;

typedef String NewsBody;

typedef String NewsURL;

/**

			a unique identifier for a news
		
*/
typedef uint32 NewsId;

typedef std::vector<NewsId> ListOfNewsId;

/**

			a news content: header + body
		
*/
class NewsContent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Category);
			init_feedos_type (m_Type);
			init_feedos_type (m_Submitter);
			init_feedos_type (m_Language);
			init_feedos_type (m_SubmitDate);
			init_feedos_type (m_ModifyDate);
			init_feedos_type (m_ExpirationDate);
			init_feedos_type (m_Headline);
			init_feedos_type (m_Keywords);
			init_feedos_type (m_RelatedMarket);
			init_feedos_type (m_RelatedCompanies);
			init_feedos_type (m_RelatedInstruments);
			init_feedos_type (m_Body);
			init_feedos_type (m_URL);
		}

		NewsContent() { reset(); }

		inline NewsContent(NewsContent const & c) :
			m_Category(c.m_Category),
			m_Type(c.m_Type),
			m_Submitter(c.m_Submitter),
			m_Language(c.m_Language),
			m_SubmitDate(c.m_SubmitDate),
			m_ModifyDate(c.m_ModifyDate),
			m_ExpirationDate(c.m_ExpirationDate),
			m_Headline(c.m_Headline),
			m_Keywords(c.m_Keywords),
			m_RelatedMarket(c.m_RelatedMarket),
			m_RelatedCompanies(c.m_RelatedCompanies),
			m_RelatedInstruments(c.m_RelatedInstruments),
			m_Body(c.m_Body),
			m_URL(c.m_URL)
		{}
		NewsContent(NewsCategory category, NewsType type, NewsSubmitter const & submitter, ISOLanguageCode const & language, Timestamp const & submitdate, Timestamp const & modifydate, Timestamp const & expirationdate, NewsHeadline const & headline, ListOfNewsKeyword const & keywords, FOSMarketId relatedmarket, ListOfCompanyId const & relatedcompanies, ListOfFOSInstrumentCode const & relatedinstruments, NewsBody const & body, NewsURL const & url) :
			m_Category(category),
			m_Type(type),
			m_Submitter(submitter),
			m_Language(language),
			m_SubmitDate(submitdate),
			m_ModifyDate(modifydate),
			m_ExpirationDate(expirationdate),
			m_Headline(headline),
			m_Keywords(keywords),
			m_RelatedMarket(relatedmarket),
			m_RelatedCompanies(relatedcompanies),
			m_RelatedInstruments(relatedinstruments),
			m_Body(body),
			m_URL(url)
		{}

		NewsContent const & operator =(NewsContent const & c)
		{
			m_Category = c.m_Category;
			m_Type = c.m_Type;
			m_Submitter = c.m_Submitter;
			m_Language = c.m_Language;
			m_SubmitDate = c.m_SubmitDate;
			m_ModifyDate = c.m_ModifyDate;
			m_ExpirationDate = c.m_ExpirationDate;
			m_Headline = c.m_Headline;
			m_Keywords = c.m_Keywords;
			m_RelatedMarket = c.m_RelatedMarket;
			m_RelatedCompanies = c.m_RelatedCompanies;
			m_RelatedInstruments = c.m_RelatedInstruments;
			m_Body = c.m_Body;
			m_URL = c.m_URL;
			return *this;
		}

		bool operator ==(NewsContent const & c) const
		{
			return (m_Category == c.m_Category) && (m_Type == c.m_Type) && (m_Submitter == c.m_Submitter) && (m_Language == c.m_Language) && (m_SubmitDate == c.m_SubmitDate) && (m_ModifyDate == c.m_ModifyDate) && (m_ExpirationDate == c.m_ExpirationDate) && (m_Headline == c.m_Headline) && (m_Keywords == c.m_Keywords) && (m_RelatedMarket == c.m_RelatedMarket) && (m_RelatedCompanies == c.m_RelatedCompanies) && (m_RelatedInstruments == c.m_RelatedInstruments) && (m_Body == c.m_Body) && (m_URL == c.m_URL);
		}

	public:
		NewsCategory getCategory() const { return m_Category; }
		NewsCategory & getCategory() { return m_Category; }
		NewsType getType() const { return m_Type; }
		NewsType & getType() { return m_Type; }
		NewsSubmitter const & getSubmitter() const { return m_Submitter; }
		NewsSubmitter & getSubmitter() { return m_Submitter; }
		ISOLanguageCode const & getLanguage() const { return m_Language; }
		ISOLanguageCode & getLanguage() { return m_Language; }
		Timestamp const & getSubmitDate() const { return m_SubmitDate; }
		Timestamp & getSubmitDate() { return m_SubmitDate; }
		Timestamp const & getModifyDate() const { return m_ModifyDate; }
		Timestamp & getModifyDate() { return m_ModifyDate; }
		Timestamp const & getExpirationDate() const { return m_ExpirationDate; }
		Timestamp & getExpirationDate() { return m_ExpirationDate; }
		NewsHeadline const & getHeadline() const { return m_Headline; }
		NewsHeadline & getHeadline() { return m_Headline; }
		ListOfNewsKeyword const & getKeywords() const { return m_Keywords; }
		ListOfNewsKeyword & getKeywords() { return m_Keywords; }
		FOSMarketId getRelatedMarket() const { return m_RelatedMarket; }
		FOSMarketId & getRelatedMarket() { return m_RelatedMarket; }
		ListOfCompanyId const & getRelatedCompanies() const { return m_RelatedCompanies; }
		ListOfCompanyId & getRelatedCompanies() { return m_RelatedCompanies; }
		ListOfFOSInstrumentCode const & getRelatedInstruments() const { return m_RelatedInstruments; }
		ListOfFOSInstrumentCode & getRelatedInstruments() { return m_RelatedInstruments; }
		NewsBody const & getBody() const { return m_Body; }
		NewsBody & getBody() { return m_Body; }
		NewsURL const & getURL() const { return m_URL; }
		NewsURL & getURL() { return m_URL; }

	public:
		void setCategory(NewsCategory category) { m_Category = category; }
		void setType(NewsType type) { m_Type = type; }
		void setSubmitter(NewsSubmitter const & submitter) { m_Submitter = submitter; }
		void setLanguage(ISOLanguageCode const & language) { m_Language = language; }
		void setSubmitDate(Timestamp const & submitdate) { m_SubmitDate = submitdate; }
		void setModifyDate(Timestamp const & modifydate) { m_ModifyDate = modifydate; }
		void setExpirationDate(Timestamp const & expirationdate) { m_ExpirationDate = expirationdate; }
		void setHeadline(NewsHeadline const & headline) { m_Headline = headline; }
		void setKeywords(ListOfNewsKeyword const & keywords) { m_Keywords = keywords; }
		inline void swapKeywords(ListOfNewsKeyword & keywords) { m_Keywords.swap(keywords); }
		void setRelatedMarket(FOSMarketId relatedmarket) { m_RelatedMarket = relatedmarket; }
		void setRelatedCompanies(ListOfCompanyId const & relatedcompanies) { m_RelatedCompanies = relatedcompanies; }
		inline void swapRelatedCompanies(ListOfCompanyId & relatedcompanies) { m_RelatedCompanies.swap(relatedcompanies); }
		void setRelatedInstruments(ListOfFOSInstrumentCode const & relatedinstruments) { m_RelatedInstruments = relatedinstruments; }
		inline void swapRelatedInstruments(ListOfFOSInstrumentCode & relatedinstruments) { m_RelatedInstruments.swap(relatedinstruments); }
		void setBody(NewsBody const & body) { m_Body = body; }
		void setURL(NewsURL const & url) { m_URL = url; }

	protected:
		NewsCategory m_Category;
		NewsType m_Type;
		NewsSubmitter m_Submitter;
		ISOLanguageCode m_Language;
		Timestamp m_SubmitDate;
		Timestamp m_ModifyDate;
		Timestamp m_ExpirationDate;
		NewsHeadline m_Headline;
		ListOfNewsKeyword m_Keywords;
		FOSMarketId m_RelatedMarket;
		ListOfCompanyId m_RelatedCompanies;
		ListOfFOSInstrumentCode m_RelatedInstruments;
		NewsBody m_Body;
		NewsURL m_URL;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <category:NewsCategory>\n"
			  << marge << "   <type:NewsType>\n"
			  << marge << "   <submitter:NewsSubmitter>\n"
			  << marge << "   <language:ISOLanguageCode>\n"
			  << marge << "   <submitdate:Timestamp>\n"
			  << marge << "   <modifydate:Timestamp>\n"
			  << marge << "   <expirationdate:Timestamp>\n"
			  << marge << "   <headline:NewsHeadline>\n"
			  << marge << "   ( <keywords:NewsKeyword> )\n"
			  << marge << "   <relatedmarket:FOSMarketId>\n"
			  << marge << "   ( <relatedcompanies:CompanyId> )\n"
			  << marge << "   ( <relatedinstruments:FOSInstrumentCode> )\n"
			  << marge << "   <body:NewsBody>\n"
			  << marge << "   <url:NewsURL>\n"
			  << marge << " }\n";
		}
};

typedef Any NewsFieldValue;

/**

			a field of a News article, with its value
		
*/
class NewsField
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_FieldId);
			init_feedos_type (m_FieldValue);
		}

		NewsField() { reset(); }

		inline NewsField(NewsField const & c) :
			m_FieldId(c.m_FieldId),
			m_FieldValue(c.m_FieldValue)
		{}
		NewsField(NewsFieldId fieldid, NewsFieldValue const & fieldvalue) :
			m_FieldId(fieldid),
			m_FieldValue(fieldvalue)
		{}

		NewsField const & operator =(NewsField const & c)
		{
			m_FieldId = c.m_FieldId;
			m_FieldValue = c.m_FieldValue;
			return *this;
		}

		bool operator ==(NewsField const & c) const
		{
			return (m_FieldId == c.m_FieldId) && (m_FieldValue == c.m_FieldValue);
		}

	public:
		NewsFieldId getFieldId() const { return m_FieldId; }
		NewsFieldId & getFieldId() { return m_FieldId; }
		NewsFieldValue const & getFieldValue() const { return m_FieldValue; }
		NewsFieldValue & getFieldValue() { return m_FieldValue; }

	public:
		void setFieldId(NewsFieldId fieldid) { m_FieldId = fieldid; }
		void setFieldValue(NewsFieldValue const & fieldvalue) { m_FieldValue = fieldvalue; }

	protected:
		NewsFieldId m_FieldId;
		NewsFieldValue m_FieldValue;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <fieldid:NewsFieldId>\n"
			  << marge << "   <fieldvalue:NewsFieldValue>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<NewsField> ListOfNewsField;

/**

			a news: ID + content
		
*/
class News
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Id);
			init_feedos_type (m_Content);
		}

		News() { reset(); }

		inline News(News const & c) :
			m_Id(c.m_Id),
			m_Content(c.m_Content)
		{}
		News(NewsId id, NewsContent const & content) :
			m_Id(id),
			m_Content(content)
		{}

		News const & operator =(News const & c)
		{
			m_Id = c.m_Id;
			m_Content = c.m_Content;
			return *this;
		}

		bool operator ==(News const & c) const
		{
			return (m_Id == c.m_Id) && (m_Content == c.m_Content);
		}

	public:
		NewsId getId() const { return m_Id; }
		NewsId & getId() { return m_Id; }
		NewsContent const & getContent() const { return m_Content; }
		NewsContent & getContent() { return m_Content; }

	public:
		void setId(NewsId id) { m_Id = id; }
		void setContent(NewsContent const & content) { m_Content = content; }

	protected:
		NewsId m_Id;
		NewsContent m_Content;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <id:NewsId>\n"
			  << marge << "   ";
			NewsContent::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<News> ListOfNews;

/**
	
*/
typedef TagNumber NewsItemId;

typedef std::vector<NewsItemId> ListOfNewsItemId;

/**
 an item of a News 
*/
typedef TagNumAndValue NewsItem;

typedef std::vector<NewsItem> ListOfNewsItem;

/**
 unique identifier for a NewsData 
*/
typedef FOSUuid NewsUuid;

typedef std::vector<NewsUuid> ListOfNewsUuid;

/**
  a News: a list of items 
*/
class NewsDetails
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ServerUTCTime);
			init_feedos_type (m_Items);
		}

		NewsDetails() { reset(); }

		inline NewsDetails(NewsDetails const & c) :
			m_ServerUTCTime(c.m_ServerUTCTime),
			m_Items(c.m_Items)
		{}
		NewsDetails(Timestamp const & serverutctime, ListOfNewsItem const & items) :
			m_ServerUTCTime(serverutctime),
			m_Items(items)
		{}

		NewsDetails const & operator =(NewsDetails const & c)
		{
			m_ServerUTCTime = c.m_ServerUTCTime;
			m_Items = c.m_Items;
			return *this;
		}

		bool operator ==(NewsDetails const & c) const
		{
			return (m_ServerUTCTime == c.m_ServerUTCTime) && (m_Items == c.m_Items);
		}

	public:
		Timestamp const & getServerUTCTime() const { return m_ServerUTCTime; }
		Timestamp & getServerUTCTime() { return m_ServerUTCTime; }
		ListOfNewsItem const & getItems() const { return m_Items; }
		ListOfNewsItem & getItems() { return m_Items; }

	public:
		void setServerUTCTime(Timestamp const & serverutctime) { m_ServerUTCTime = serverutctime; }
		void setItems(ListOfNewsItem const & items) { m_Items = items; }
		inline void swapItems(ListOfNewsItem & items) { m_Items.swap(items); }

	protected:
		Timestamp m_ServerUTCTime;
		ListOfNewsItem m_Items;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <serverutctime:Timestamp>\n"
			  << marge << "   ( <items:NewsItem> )\n"
			  << marge << " }\n";
		}
};

/**
  a News: a list of items 
*/
class NewsData
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Type);
			init_feedos_type (m_Id);
			init_feedos_type (m_ServerUTCTime);
			init_feedos_type (m_Items);
		}

		NewsData() { reset(); }

		inline NewsData(NewsData const & c) :
			m_Type(c.m_Type),
			m_Id(c.m_Id),
			m_ServerUTCTime(c.m_ServerUTCTime),
			m_Items(c.m_Items)
		{}
		NewsData(NewsEventType type, NewsUuid const & id, Timestamp const & serverutctime, ListOfNewsItem const & items) :
			m_Type(type),
			m_Id(id),
			m_ServerUTCTime(serverutctime),
			m_Items(items)
		{}

		NewsData const & operator =(NewsData const & c)
		{
			m_Type = c.m_Type;
			m_Id = c.m_Id;
			m_ServerUTCTime = c.m_ServerUTCTime;
			m_Items = c.m_Items;
			return *this;
		}

		bool operator ==(NewsData const & c) const
		{
			return (m_Type == c.m_Type) && (m_Id == c.m_Id) && (m_ServerUTCTime == c.m_ServerUTCTime) && (m_Items == c.m_Items);
		}

	public:
		NewsEventType getType() const { return m_Type; }
		NewsEventType & getType() { return m_Type; }
		NewsUuid const & getId() const { return m_Id; }
		NewsUuid & getId() { return m_Id; }
		Timestamp const & getServerUTCTime() const { return m_ServerUTCTime; }
		Timestamp & getServerUTCTime() { return m_ServerUTCTime; }
		ListOfNewsItem const & getItems() const { return m_Items; }
		ListOfNewsItem & getItems() { return m_Items; }

	public:
		void setType(NewsEventType type) { m_Type = type; }
		void setId(NewsUuid const & id) { m_Id = id; }
		void setServerUTCTime(Timestamp const & serverutctime) { m_ServerUTCTime = serverutctime; }
		void setItems(ListOfNewsItem const & items) { m_Items = items; }
		inline void swapItems(ListOfNewsItem & items) { m_Items.swap(items); }

	protected:
		NewsEventType m_Type;
		NewsUuid m_Id;
		Timestamp m_ServerUTCTime;
		ListOfNewsItem m_Items;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <type:NewsEventType>\n"
			  << marge << "   ";
			FOSUuid::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <serverutctime:Timestamp>\n"
			  << marge << "   ( <items:NewsItem> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<NewsData> ListOfNewsData;

/**

			A user's group identifier.
		
*/
typedef uint32 UserGroupId;

/**

			A user's identifier.
		
*/
typedef uint32 UserId;

typedef std::vector<UserId> ListOfUserId;

/**

			A user's group. Gives the list of permissions.
		
*/
class UserGroupCharacteristics
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Id);
			init_feedos_type (m_Name);
			init_feedos_type (m_AllowedRequests);
		}

		UserGroupCharacteristics() { reset(); }

		inline UserGroupCharacteristics(UserGroupCharacteristics const & c) :
			m_Id(c.m_Id),
			m_Name(c.m_Name),
			m_AllowedRequests(c.m_AllowedRequests)
		{}
		UserGroupCharacteristics(UserGroupId id, String const & name, ListOfFeedOSCmd const & allowedrequests) :
			m_Id(id),
			m_Name(name),
			m_AllowedRequests(allowedrequests)
		{}

		UserGroupCharacteristics const & operator =(UserGroupCharacteristics const & c)
		{
			m_Id = c.m_Id;
			m_Name = c.m_Name;
			m_AllowedRequests = c.m_AllowedRequests;
			return *this;
		}

		bool operator ==(UserGroupCharacteristics const & c) const
		{
			return (m_Id == c.m_Id) && (m_Name == c.m_Name) && (m_AllowedRequests == c.m_AllowedRequests);
		}

	public:
		UserGroupId getId() const { return m_Id; }
		UserGroupId & getId() { return m_Id; }
		String const & getName() const { return m_Name; }
		String & getName() { return m_Name; }
		ListOfFeedOSCmd const & getAllowedRequests() const { return m_AllowedRequests; }
		ListOfFeedOSCmd & getAllowedRequests() { return m_AllowedRequests; }

	public:
		void setId(UserGroupId id) { m_Id = id; }
		void setName(String const & name) { m_Name = name; }
		void setAllowedRequests(ListOfFeedOSCmd const & allowedrequests) { m_AllowedRequests = allowedrequests; }
		inline void swapAllowedRequests(ListOfFeedOSCmd & allowedrequests) { m_AllowedRequests.swap(allowedrequests); }

	protected:
		UserGroupId m_Id;
		String m_Name;
		ListOfFeedOSCmd m_AllowedRequests;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <id:UserGroupId>\n"
			  << marge << "   <name:String>\n"
			  << marge << "   ( <allowedrequests:FeedOSCmd> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<UserGroupCharacteristics> ListOfUserGroupCharacteristics;

/**

		
*/
class MarketAccessFeature
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Name);
			init_feedos_type (m_Value);
		}

		MarketAccessFeature() { reset(); }

		inline MarketAccessFeature(MarketAccessFeature const & c) :
			m_Name(c.m_Name),
			m_Value(c.m_Value)
		{}
		MarketAccessFeature(String const & name, Any const & value) :
			m_Name(name),
			m_Value(value)
		{}

		MarketAccessFeature const & operator =(MarketAccessFeature const & c)
		{
			m_Name = c.m_Name;
			m_Value = c.m_Value;
			return *this;
		}

		bool operator ==(MarketAccessFeature const & c) const
		{
			return (m_Name == c.m_Name) && (m_Value == c.m_Value);
		}

	public:
		String const & getName() const { return m_Name; }
		String & getName() { return m_Name; }
		Any const & getValue() const { return m_Value; }
		Any & getValue() { return m_Value; }

	public:
		void setName(String const & name) { m_Name = name; }
		void setValue(Any const & value) { m_Value = value; }

	protected:
		String m_Name;
		Any m_Value;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <name:String>\n"
			  << marge << "   <value:Any>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<MarketAccessFeature> ListOfMarketAccessFeature;

/**

			Market Access Permission entry
		
*/
class MarketAccessPermissions
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_InternalSourceId);
			init_feedos_type (m_BranchIdPattern);
			init_feedos_type (m_Features);
		}

		MarketAccessPermissions() { reset(); }

		inline MarketAccessPermissions(MarketAccessPermissions const & c) :
			m_InternalSourceId(c.m_InternalSourceId),
			m_BranchIdPattern(c.m_BranchIdPattern),
			m_Features(c.m_Features)
		{}
		MarketAccessPermissions(int32 internalsourceid, MarketBranchId const & branchidpattern, ListOfMarketAccessFeature const & features) :
			m_InternalSourceId(internalsourceid),
			m_BranchIdPattern(branchidpattern),
			m_Features(features)
		{}

		MarketAccessPermissions const & operator =(MarketAccessPermissions const & c)
		{
			m_InternalSourceId = c.m_InternalSourceId;
			m_BranchIdPattern = c.m_BranchIdPattern;
			m_Features = c.m_Features;
			return *this;
		}

		bool operator ==(MarketAccessPermissions const & c) const
		{
			return (m_InternalSourceId == c.m_InternalSourceId) && (m_BranchIdPattern == c.m_BranchIdPattern) && (m_Features == c.m_Features);
		}

	public:
		int32 getInternalSourceId() const { return m_InternalSourceId; }
		int32 & getInternalSourceId() { return m_InternalSourceId; }
		MarketBranchId const & getBranchIdPattern() const { return m_BranchIdPattern; }
		MarketBranchId & getBranchIdPattern() { return m_BranchIdPattern; }
		ListOfMarketAccessFeature const & getFeatures() const { return m_Features; }
		ListOfMarketAccessFeature & getFeatures() { return m_Features; }

	public:
		void setInternalSourceId(int32 internalsourceid) { m_InternalSourceId = internalsourceid; }
		void setBranchIdPattern(MarketBranchId const & branchidpattern) { m_BranchIdPattern = branchidpattern; }
		void setFeatures(ListOfMarketAccessFeature const & features) { m_Features = features; }
		inline void swapFeatures(ListOfMarketAccessFeature & features) { m_Features.swap(features); }

	protected:
		int32 m_InternalSourceId;
		MarketBranchId m_BranchIdPattern;
		ListOfMarketAccessFeature m_Features;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <internalsourceid:int32>\n"
			  << marge << "   ";
			MarketBranchId::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ( <features:MarketAccessFeature> )\n";
			MarketAccessFeature::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<MarketAccessPermissions> ListOfMarketAccessPermissions;

/**

			A user.
		
*/
class UserCharacteristics
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Id);
			init_feedos_type (m_GID);
			init_feedos_type (m_Name);
			init_feedos_type (m_Password);
			init_feedos_type (m_Location);
			init_feedos_type (m_MaxConnections);
			init_feedos_type (m_ExpirationDate);
			init_feedos_type (m_MarketAccess);
		}

		UserCharacteristics() { reset(); }

		inline UserCharacteristics(UserCharacteristics const & c) :
			m_Id(c.m_Id),
			m_GID(c.m_GID),
			m_Name(c.m_Name),
			m_Password(c.m_Password),
			m_Location(c.m_Location),
			m_MaxConnections(c.m_MaxConnections),
			m_ExpirationDate(c.m_ExpirationDate),
			m_MarketAccess(c.m_MarketAccess)
		{}
		UserCharacteristics(UserId id, UserGroupId gid, String const & name, String const & password, String const & location, uint16 maxconnections, Timestamp const & expirationdate, ListOfMarketAccessPermissions const & marketaccess) :
			m_Id(id),
			m_GID(gid),
			m_Name(name),
			m_Password(password),
			m_Location(location),
			m_MaxConnections(maxconnections),
			m_ExpirationDate(expirationdate),
			m_MarketAccess(marketaccess)
		{}

		UserCharacteristics const & operator =(UserCharacteristics const & c)
		{
			m_Id = c.m_Id;
			m_GID = c.m_GID;
			m_Name = c.m_Name;
			m_Password = c.m_Password;
			m_Location = c.m_Location;
			m_MaxConnections = c.m_MaxConnections;
			m_ExpirationDate = c.m_ExpirationDate;
			m_MarketAccess = c.m_MarketAccess;
			return *this;
		}

		bool operator ==(UserCharacteristics const & c) const
		{
			return (m_Id == c.m_Id) && (m_GID == c.m_GID) && (m_Name == c.m_Name) && (m_Password == c.m_Password) && (m_Location == c.m_Location) && (m_MaxConnections == c.m_MaxConnections) && (m_ExpirationDate == c.m_ExpirationDate) && (m_MarketAccess == c.m_MarketAccess);
		}

	public:
		UserId getId() const { return m_Id; }
		UserId & getId() { return m_Id; }
		UserGroupId getGID() const { return m_GID; }
		UserGroupId & getGID() { return m_GID; }
		String const & getName() const { return m_Name; }
		String & getName() { return m_Name; }
		String const & getPassword() const { return m_Password; }
		String & getPassword() { return m_Password; }
		String const & getLocation() const { return m_Location; }
		String & getLocation() { return m_Location; }
		uint16 getMaxConnections() const { return m_MaxConnections; }
		uint16 & getMaxConnections() { return m_MaxConnections; }
		Timestamp const & getExpirationDate() const { return m_ExpirationDate; }
		Timestamp & getExpirationDate() { return m_ExpirationDate; }
		ListOfMarketAccessPermissions const & getMarketAccess() const { return m_MarketAccess; }
		ListOfMarketAccessPermissions & getMarketAccess() { return m_MarketAccess; }

	public:
		void setId(UserId id) { m_Id = id; }
		void setGID(UserGroupId gid) { m_GID = gid; }
		void setName(String const & name) { m_Name = name; }
		void setPassword(String const & password) { m_Password = password; }
		void setLocation(String const & location) { m_Location = location; }
		void setMaxConnections(uint16 maxconnections) { m_MaxConnections = maxconnections; }
		void setExpirationDate(Timestamp const & expirationdate) { m_ExpirationDate = expirationdate; }
		void setMarketAccess(ListOfMarketAccessPermissions const & marketaccess) { m_MarketAccess = marketaccess; }
		inline void swapMarketAccess(ListOfMarketAccessPermissions & marketaccess) { m_MarketAccess.swap(marketaccess); }

	protected:
		UserId m_Id;
		UserGroupId m_GID;
		String m_Name;
		String m_Password;
		String m_Location;
		uint16 m_MaxConnections;
		Timestamp m_ExpirationDate;
		ListOfMarketAccessPermissions m_MarketAccess;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <id:UserId>\n"
			  << marge << "   <gid:UserGroupId>\n"
			  << marge << "   <name:String>\n"
			  << marge << "   <password:String>\n"
			  << marge << "   <location:String>\n"
			  << marge << "   <maxconnections:uint16>\n"
			  << marge << "   <expirationdate:Timestamp>\n"
			  << marge << "   ( <marketaccess:MarketAccessPermissions> )\n";
			MarketAccessPermissions::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<UserCharacteristics> ListOfUserCharacteristics;

class UserStat
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Id);
			init_feedos_type (m_Name);
			init_feedos_type (m_NbConnections);
		}

		UserStat() { reset(); }

		inline UserStat(UserStat const & c) :
			m_Id(c.m_Id),
			m_Name(c.m_Name),
			m_NbConnections(c.m_NbConnections)
		{}
		UserStat(UserId id, String const & name, uint16 nbconnections) :
			m_Id(id),
			m_Name(name),
			m_NbConnections(nbconnections)
		{}

		UserStat const & operator =(UserStat const & c)
		{
			m_Id = c.m_Id;
			m_Name = c.m_Name;
			m_NbConnections = c.m_NbConnections;
			return *this;
		}

		bool operator ==(UserStat const & c) const
		{
			return (m_Id == c.m_Id) && (m_Name == c.m_Name) && (m_NbConnections == c.m_NbConnections);
		}

	public:
		UserId getId() const { return m_Id; }
		UserId & getId() { return m_Id; }
		String const & getName() const { return m_Name; }
		String & getName() { return m_Name; }
		uint16 getNbConnections() const { return m_NbConnections; }
		uint16 & getNbConnections() { return m_NbConnections; }

	public:
		void setId(UserId id) { m_Id = id; }
		void setName(String const & name) { m_Name = name; }
		void setNbConnections(uint16 nbconnections) { m_NbConnections = nbconnections; }

	protected:
		UserId m_Id;
		String m_Name;
		uint16 m_NbConnections;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <id:UserId>\n"
			  << marge << "   <name:String>\n"
			  << marge << "   <nbconnections:uint16>\n"
			  << marge << " }\n";
		}
};

/**
	
*/
typedef uint16 MarketSheetLevel;

/**

			market sheet order
		
*/
class MarketSheetEntry
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_OrderID);
			init_feedos_type (m_Price);
			init_feedos_type (m_Qty);
		}

		MarketSheetEntry() { reset(); }

		inline MarketSheetEntry(MarketSheetEntry const & c) :
			m_OrderID(c.m_OrderID),
			m_Price(c.m_Price),
			m_Qty(c.m_Qty)
		{}
		MarketSheetEntry(String const & orderid, float64 price, float64 qty) :
			m_OrderID(orderid),
			m_Price(price),
			m_Qty(qty)
		{}

		MarketSheetEntry const & operator =(MarketSheetEntry const & c)
		{
			m_OrderID = c.m_OrderID;
			m_Price = c.m_Price;
			m_Qty = c.m_Qty;
			return *this;
		}

		bool operator ==(MarketSheetEntry const & c) const
		{
			return (m_OrderID == c.m_OrderID) && (m_Price == c.m_Price) && (m_Qty == c.m_Qty);
		}

	public:
		String const & getOrderID() const { return m_OrderID; }
		String & getOrderID() { return m_OrderID; }
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getQty() const { return m_Qty; }
		float64 & getQty() { return m_Qty; }

	public:
		void setOrderID(String const & orderid) { m_OrderID = orderid; }
		void setPrice(float64 price) { m_Price = price; }
		void setQty(float64 qty) { m_Qty = qty; }

	protected:
		String m_OrderID;
		float64 m_Price;
		float64 m_Qty;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <orderid:String>\n"
			  << marge << "   <price:float64>\n"
			  << marge << "   <qty:float64>\n"
			  << marge << " }\n";
		}
};

/**

			market sheet order and context
		
*/
class MarketSheetEntryAndContext
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Order);
			init_feedos_type (m_Context);
		}

		MarketSheetEntryAndContext() { reset(); }

		inline MarketSheetEntryAndContext(MarketSheetEntryAndContext const & c) :
			m_Order(c.m_Order),
			m_Context(c.m_Context)
		{}
		MarketSheetEntryAndContext(MarketSheetEntry const & order, ListOfQuotationContextFlag const & context) :
			m_Order(order),
			m_Context(context)
		{}

		MarketSheetEntryAndContext const & operator =(MarketSheetEntryAndContext const & c)
		{
			m_Order = c.m_Order;
			m_Context = c.m_Context;
			return *this;
		}

		bool operator ==(MarketSheetEntryAndContext const & c) const
		{
			return (m_Order == c.m_Order) && (m_Context == c.m_Context);
		}

	public:
		MarketSheetEntry const & getOrder() const { return m_Order; }
		MarketSheetEntry & getOrder() { return m_Order; }
		ListOfQuotationContextFlag const & getContext() const { return m_Context; }
		ListOfQuotationContextFlag & getContext() { return m_Context; }

	public:
		void setOrder(MarketSheetEntry const & order) { m_Order = order; }
		void setContext(ListOfQuotationContextFlag const & context) { m_Context = context; }
		inline void swapContext(ListOfQuotationContextFlag & context) { m_Context.swap(context); }

	protected:
		MarketSheetEntry m_Order;
		ListOfQuotationContextFlag m_Context;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			MarketSheetEntry::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ( <context:QuotationContextFlag> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<MarketSheetEntryAndContext> ListOfMarketSheetEntryAndContext;

/**

			market sheet
		
*/
class MarketSheet
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_BidSide);
			init_feedos_type (m_AskSide);
		}

		MarketSheet() { reset(); }

		inline MarketSheet(MarketSheet const & c) :
			m_BidSide(c.m_BidSide),
			m_AskSide(c.m_AskSide)
		{}
		MarketSheet(ListOfMarketSheetEntryAndContext const & bidside, ListOfMarketSheetEntryAndContext const & askside) :
			m_BidSide(bidside),
			m_AskSide(askside)
		{}

		MarketSheet const & operator =(MarketSheet const & c)
		{
			m_BidSide = c.m_BidSide;
			m_AskSide = c.m_AskSide;
			return *this;
		}

		bool operator ==(MarketSheet const & c) const
		{
			return (m_BidSide == c.m_BidSide) && (m_AskSide == c.m_AskSide);
		}

	public:
		ListOfMarketSheetEntryAndContext const & getBidSide() const { return m_BidSide; }
		ListOfMarketSheetEntryAndContext & getBidSide() { return m_BidSide; }
		ListOfMarketSheetEntryAndContext const & getAskSide() const { return m_AskSide; }
		ListOfMarketSheetEntryAndContext & getAskSide() { return m_AskSide; }

	public:
		void setBidSide(ListOfMarketSheetEntryAndContext const & bidside) { m_BidSide = bidside; }
		inline void swapBidSide(ListOfMarketSheetEntryAndContext & bidside) { m_BidSide.swap(bidside); }
		void setAskSide(ListOfMarketSheetEntryAndContext const & askside) { m_AskSide = askside; }
		inline void swapAskSide(ListOfMarketSheetEntryAndContext & askside) { m_AskSide.swap(askside); }

	protected:
		ListOfMarketSheetEntryAndContext m_BidSide;
		ListOfMarketSheetEntryAndContext m_AskSide;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ( <bidside:MarketSheetEntryAndContext> )\n";
			MarketSheetEntryAndContext::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <askside:MarketSheetEntryAndContext> )\n";
			MarketSheetEntryAndContext::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

/**

			instrument MBO data
		
*/
class InstrumentStatusMarketSheet
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_ServerUTCTimestamp);
			init_feedos_type (m_MarketUTCTimestamp);
			init_feedos_type (m_MarketSheet);
			init_feedos_type (m_Values);
		}

		InstrumentStatusMarketSheet() { reset(); }

		inline InstrumentStatusMarketSheet(InstrumentStatusMarketSheet const & c) :
			m_Code(c.m_Code),
			m_ServerUTCTimestamp(c.m_ServerUTCTimestamp),
			m_MarketUTCTimestamp(c.m_MarketUTCTimestamp),
			m_MarketSheet(c.m_MarketSheet),
			m_Values(c.m_Values)
		{}
		InstrumentStatusMarketSheet(FOSInstrumentCode code, Timestamp const & serverutctimestamp, Timestamp const & marketutctimestamp, MarketSheet const & marketsheet, ListOfQuotationVariable const & values) :
			m_Code(code),
			m_ServerUTCTimestamp(serverutctimestamp),
			m_MarketUTCTimestamp(marketutctimestamp),
			m_MarketSheet(marketsheet),
			m_Values(values)
		{}

		InstrumentStatusMarketSheet const & operator =(InstrumentStatusMarketSheet const & c)
		{
			m_Code = c.m_Code;
			m_ServerUTCTimestamp = c.m_ServerUTCTimestamp;
			m_MarketUTCTimestamp = c.m_MarketUTCTimestamp;
			m_MarketSheet = c.m_MarketSheet;
			m_Values = c.m_Values;
			return *this;
		}

		bool operator ==(InstrumentStatusMarketSheet const & c) const
		{
			return (m_Code == c.m_Code) && (m_ServerUTCTimestamp == c.m_ServerUTCTimestamp) && (m_MarketUTCTimestamp == c.m_MarketUTCTimestamp) && (m_MarketSheet == c.m_MarketSheet) && (m_Values == c.m_Values);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		Timestamp const & getServerUTCTimestamp() const { return m_ServerUTCTimestamp; }
		Timestamp & getServerUTCTimestamp() { return m_ServerUTCTimestamp; }
		Timestamp const & getMarketUTCTimestamp() const { return m_MarketUTCTimestamp; }
		Timestamp & getMarketUTCTimestamp() { return m_MarketUTCTimestamp; }
		MarketSheet const & getMarketSheet() const { return m_MarketSheet; }
		MarketSheet & getMarketSheet() { return m_MarketSheet; }
		ListOfQuotationVariable const & getValues() const { return m_Values; }
		ListOfQuotationVariable & getValues() { return m_Values; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setServerUTCTimestamp(Timestamp const & serverutctimestamp) { m_ServerUTCTimestamp = serverutctimestamp; }
		void setMarketUTCTimestamp(Timestamp const & marketutctimestamp) { m_MarketUTCTimestamp = marketutctimestamp; }
		void setMarketSheet(MarketSheet const & marketsheet) { m_MarketSheet = marketsheet; }
		void setValues(ListOfQuotationVariable const & values) { m_Values = values; }
		inline void swapValues(ListOfQuotationVariable & values) { m_Values.swap(values); }

	protected:
		FOSInstrumentCode m_Code;
		Timestamp m_ServerUTCTimestamp;
		Timestamp m_MarketUTCTimestamp;
		MarketSheet m_MarketSheet;
		ListOfQuotationVariable m_Values;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   <serverutctimestamp:Timestamp>\n"
			  << marge << "   <marketutctimestamp:Timestamp>\n"
			  << marge << "   ";
			MarketSheet::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ( <values:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<InstrumentStatusMarketSheet> ListOfInstrumentStatusMarketSheet;

/**

			header data of a multicast frame
		
*/
class MulticastFrameHeaderStruct
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_FrameSequenceNumber);
			init_feedos_type (m_FrameServerDate_seconds);
			init_feedos_type (m_FrameServerDate_millisec);
			init_feedos_type (m_FrameServerDate_microsec);
			init_feedos_type (m_FrameDuration_microsec);
			init_feedos_type (m_NbMessagesInFrame);
		}

		MulticastFrameHeaderStruct() { reset(); }

		inline MulticastFrameHeaderStruct(MulticastFrameHeaderStruct const & c) :
			m_FrameSequenceNumber(c.m_FrameSequenceNumber),
			m_FrameServerDate_seconds(c.m_FrameServerDate_seconds),
			m_FrameServerDate_millisec(c.m_FrameServerDate_millisec),
			m_FrameServerDate_microsec(c.m_FrameServerDate_microsec),
			m_FrameDuration_microsec(c.m_FrameDuration_microsec),
			m_NbMessagesInFrame(c.m_NbMessagesInFrame)
		{}
		MulticastFrameHeaderStruct(uint32 framesequencenumber, uint32 frameserverdate_seconds, uint16 frameserverdate_millisec, uint16 frameserverdate_microsec, uint32 frameduration_microsec, uint16 nbmessagesinframe) :
			m_FrameSequenceNumber(framesequencenumber),
			m_FrameServerDate_seconds(frameserverdate_seconds),
			m_FrameServerDate_millisec(frameserverdate_millisec),
			m_FrameServerDate_microsec(frameserverdate_microsec),
			m_FrameDuration_microsec(frameduration_microsec),
			m_NbMessagesInFrame(nbmessagesinframe)
		{}

		MulticastFrameHeaderStruct const & operator =(MulticastFrameHeaderStruct const & c)
		{
			m_FrameSequenceNumber = c.m_FrameSequenceNumber;
			m_FrameServerDate_seconds = c.m_FrameServerDate_seconds;
			m_FrameServerDate_millisec = c.m_FrameServerDate_millisec;
			m_FrameServerDate_microsec = c.m_FrameServerDate_microsec;
			m_FrameDuration_microsec = c.m_FrameDuration_microsec;
			m_NbMessagesInFrame = c.m_NbMessagesInFrame;
			return *this;
		}

		bool operator ==(MulticastFrameHeaderStruct const & c) const
		{
			return (m_FrameSequenceNumber == c.m_FrameSequenceNumber) && (m_FrameServerDate_seconds == c.m_FrameServerDate_seconds) && (m_FrameServerDate_millisec == c.m_FrameServerDate_millisec) && (m_FrameServerDate_microsec == c.m_FrameServerDate_microsec) && (m_FrameDuration_microsec == c.m_FrameDuration_microsec) && (m_NbMessagesInFrame == c.m_NbMessagesInFrame);
		}

	public:
		uint32 getFrameSequenceNumber() const { return m_FrameSequenceNumber; }
		uint32 & getFrameSequenceNumber() { return m_FrameSequenceNumber; }
		uint32 getFrameServerDate_seconds() const { return m_FrameServerDate_seconds; }
		uint32 & getFrameServerDate_seconds() { return m_FrameServerDate_seconds; }
		uint16 getFrameServerDate_millisec() const { return m_FrameServerDate_millisec; }
		uint16 & getFrameServerDate_millisec() { return m_FrameServerDate_millisec; }
		uint16 getFrameServerDate_microsec() const { return m_FrameServerDate_microsec; }
		uint16 & getFrameServerDate_microsec() { return m_FrameServerDate_microsec; }
		uint32 getFrameDuration_microsec() const { return m_FrameDuration_microsec; }
		uint32 & getFrameDuration_microsec() { return m_FrameDuration_microsec; }
		uint16 getNbMessagesInFrame() const { return m_NbMessagesInFrame; }
		uint16 & getNbMessagesInFrame() { return m_NbMessagesInFrame; }

	public:
		void setFrameSequenceNumber(uint32 framesequencenumber) { m_FrameSequenceNumber = framesequencenumber; }
		void setFrameServerDate_seconds(uint32 frameserverdate_seconds) { m_FrameServerDate_seconds = frameserverdate_seconds; }
		void setFrameServerDate_millisec(uint16 frameserverdate_millisec) { m_FrameServerDate_millisec = frameserverdate_millisec; }
		void setFrameServerDate_microsec(uint16 frameserverdate_microsec) { m_FrameServerDate_microsec = frameserverdate_microsec; }
		void setFrameDuration_microsec(uint32 frameduration_microsec) { m_FrameDuration_microsec = frameduration_microsec; }
		void setNbMessagesInFrame(uint16 nbmessagesinframe) { m_NbMessagesInFrame = nbmessagesinframe; }

	protected:
		uint32 m_FrameSequenceNumber;
		uint32 m_FrameServerDate_seconds;
		uint16 m_FrameServerDate_millisec;
		uint16 m_FrameServerDate_microsec;
		uint32 m_FrameDuration_microsec;
		uint16 m_NbMessagesInFrame;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <framesequencenumber:uint32>\n"
			  << marge << "   <frameserverdate_seconds:uint32>\n"
			  << marge << "   <frameserverdate_millisec:uint16>\n"
			  << marge << "   <frameserverdate_microsec:uint16>\n"
			  << marge << "   <frameduration_microsec:uint32>\n"
			  << marge << "   <nbmessagesinframe:uint16>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class QuotationReplaySubject
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_InternalSourceId);
			init_feedos_type (m_RangeBeginServerDate);
			init_feedos_type (m_RangeEndServerDate);
			init_feedos_type (m_SendMulticastFrameHeader);
			init_feedos_type (m_FilterInstrumentCodes);
			init_feedos_type (m_FilterMICs);
			init_feedos_type (m_IgnoreInvalidCodes);
			init_feedos_type (m_AccelerationFactor);
		}

		QuotationReplaySubject() { reset(); }

		inline QuotationReplaySubject(QuotationReplaySubject const & c) :
			m_InternalSourceId(c.m_InternalSourceId),
			m_RangeBeginServerDate(c.m_RangeBeginServerDate),
			m_RangeEndServerDate(c.m_RangeEndServerDate),
			m_SendMulticastFrameHeader(c.m_SendMulticastFrameHeader),
			m_FilterInstrumentCodes(c.m_FilterInstrumentCodes),
			m_FilterMICs(c.m_FilterMICs),
			m_IgnoreInvalidCodes(c.m_IgnoreInvalidCodes),
			m_AccelerationFactor(c.m_AccelerationFactor)
		{}
		QuotationReplaySubject(uint16 internalsourceid, Timestamp const & rangebeginserverdate, Timestamp const & rangeendserverdate, bool sendmulticastframeheader, ListOfPolymorphicInstrumentCode const & filterinstrumentcodes, ListOfFOSMarketId const & filtermics, bool ignoreinvalidcodes, float64 accelerationfactor) :
			m_InternalSourceId(internalsourceid),
			m_RangeBeginServerDate(rangebeginserverdate),
			m_RangeEndServerDate(rangeendserverdate),
			m_SendMulticastFrameHeader(sendmulticastframeheader),
			m_FilterInstrumentCodes(filterinstrumentcodes),
			m_FilterMICs(filtermics),
			m_IgnoreInvalidCodes(ignoreinvalidcodes),
			m_AccelerationFactor(accelerationfactor)
		{}

		QuotationReplaySubject const & operator =(QuotationReplaySubject const & c)
		{
			m_InternalSourceId = c.m_InternalSourceId;
			m_RangeBeginServerDate = c.m_RangeBeginServerDate;
			m_RangeEndServerDate = c.m_RangeEndServerDate;
			m_SendMulticastFrameHeader = c.m_SendMulticastFrameHeader;
			m_FilterInstrumentCodes = c.m_FilterInstrumentCodes;
			m_FilterMICs = c.m_FilterMICs;
			m_IgnoreInvalidCodes = c.m_IgnoreInvalidCodes;
			m_AccelerationFactor = c.m_AccelerationFactor;
			return *this;
		}

		bool operator ==(QuotationReplaySubject const & c) const
		{
			return (m_InternalSourceId == c.m_InternalSourceId) && (m_RangeBeginServerDate == c.m_RangeBeginServerDate) && (m_RangeEndServerDate == c.m_RangeEndServerDate) && (m_SendMulticastFrameHeader == c.m_SendMulticastFrameHeader) && (m_FilterInstrumentCodes == c.m_FilterInstrumentCodes) && (m_FilterMICs == c.m_FilterMICs) && (m_IgnoreInvalidCodes == c.m_IgnoreInvalidCodes) && (m_AccelerationFactor == c.m_AccelerationFactor);
		}

	public:
		uint16 getInternalSourceId() const { return m_InternalSourceId; }
		uint16 & getInternalSourceId() { return m_InternalSourceId; }
		Timestamp const & getRangeBeginServerDate() const { return m_RangeBeginServerDate; }
		Timestamp & getRangeBeginServerDate() { return m_RangeBeginServerDate; }
		Timestamp const & getRangeEndServerDate() const { return m_RangeEndServerDate; }
		Timestamp & getRangeEndServerDate() { return m_RangeEndServerDate; }
		bool getSendMulticastFrameHeader() const { return m_SendMulticastFrameHeader; }
		bool & getSendMulticastFrameHeader() { return m_SendMulticastFrameHeader; }
		ListOfPolymorphicInstrumentCode const & getFilterInstrumentCodes() const { return m_FilterInstrumentCodes; }
		ListOfPolymorphicInstrumentCode & getFilterInstrumentCodes() { return m_FilterInstrumentCodes; }
		ListOfFOSMarketId const & getFilterMICs() const { return m_FilterMICs; }
		ListOfFOSMarketId & getFilterMICs() { return m_FilterMICs; }
		bool getIgnoreInvalidCodes() const { return m_IgnoreInvalidCodes; }
		bool & getIgnoreInvalidCodes() { return m_IgnoreInvalidCodes; }
		float64 getAccelerationFactor() const { return m_AccelerationFactor; }
		float64 & getAccelerationFactor() { return m_AccelerationFactor; }

	public:
		void setInternalSourceId(uint16 internalsourceid) { m_InternalSourceId = internalsourceid; }
		void setRangeBeginServerDate(Timestamp const & rangebeginserverdate) { m_RangeBeginServerDate = rangebeginserverdate; }
		void setRangeEndServerDate(Timestamp const & rangeendserverdate) { m_RangeEndServerDate = rangeendserverdate; }
		void setSendMulticastFrameHeader(bool sendmulticastframeheader) { m_SendMulticastFrameHeader = sendmulticastframeheader; }
		void setFilterInstrumentCodes(ListOfPolymorphicInstrumentCode const & filterinstrumentcodes) { m_FilterInstrumentCodes = filterinstrumentcodes; }
		inline void swapFilterInstrumentCodes(ListOfPolymorphicInstrumentCode & filterinstrumentcodes) { m_FilterInstrumentCodes.swap(filterinstrumentcodes); }
		void setFilterMICs(ListOfFOSMarketId const & filtermics) { m_FilterMICs = filtermics; }
		inline void swapFilterMICs(ListOfFOSMarketId & filtermics) { m_FilterMICs.swap(filtermics); }
		void setIgnoreInvalidCodes(bool ignoreinvalidcodes) { m_IgnoreInvalidCodes = ignoreinvalidcodes; }
		void setAccelerationFactor(float64 accelerationfactor) { m_AccelerationFactor = accelerationfactor; }

	protected:
		uint16 m_InternalSourceId;
		Timestamp m_RangeBeginServerDate;
		Timestamp m_RangeEndServerDate;
		bool m_SendMulticastFrameHeader;
		ListOfPolymorphicInstrumentCode m_FilterInstrumentCodes;
		ListOfFOSMarketId m_FilterMICs;
		bool m_IgnoreInvalidCodes;
		float64 m_AccelerationFactor;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <internalsourceid:uint16>\n"
			  << marge << "   <rangebeginserverdate:Timestamp>\n"
			  << marge << "   <rangeendserverdate:Timestamp>\n"
			  << marge << "   <sendmulticastframeheader:bool>\n"
			  << marge << "   ( <filterinstrumentcodes:PolymorphicInstrumentCode> )\n"
			  << marge << "   ( <filtermics:FOSMarketId> )\n"
			  << marge << "   <ignoreinvalidcodes:bool>\n"
			  << marge << "   <accelerationfactor:float64>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class QuotationReplayL1Filter
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_OtherValuesToLookFor);
			init_feedos_type (m_ContentMask);
		}

		QuotationReplayL1Filter() { reset(); }

		inline QuotationReplayL1Filter(QuotationReplayL1Filter const & c) :
			m_OtherValuesToLookFor(c.m_OtherValuesToLookFor),
			m_ContentMask(c.m_ContentMask)
		{}
		QuotationReplayL1Filter(ListOfQuotationTagNumber const & othervaluestolookfor, QuotationContentMask contentmask) :
			m_OtherValuesToLookFor(othervaluestolookfor),
			m_ContentMask(contentmask)
		{}

		QuotationReplayL1Filter const & operator =(QuotationReplayL1Filter const & c)
		{
			m_OtherValuesToLookFor = c.m_OtherValuesToLookFor;
			m_ContentMask = c.m_ContentMask;
			return *this;
		}

		bool operator ==(QuotationReplayL1Filter const & c) const
		{
			return (m_OtherValuesToLookFor == c.m_OtherValuesToLookFor) && (m_ContentMask == c.m_ContentMask);
		}

	public:
		ListOfQuotationTagNumber const & getOtherValuesToLookFor() const { return m_OtherValuesToLookFor; }
		ListOfQuotationTagNumber & getOtherValuesToLookFor() { return m_OtherValuesToLookFor; }
		QuotationContentMask getContentMask() const { return m_ContentMask; }
		QuotationContentMask & getContentMask() { return m_ContentMask; }

	public:
		void setOtherValuesToLookFor(ListOfQuotationTagNumber const & othervaluestolookfor) { m_OtherValuesToLookFor = othervaluestolookfor; }
		inline void swapOtherValuesToLookFor(ListOfQuotationTagNumber & othervaluestolookfor) { m_OtherValuesToLookFor.swap(othervaluestolookfor); }
		void setContentMask(QuotationContentMask contentmask) { m_ContentMask = contentmask; }

	protected:
		ListOfQuotationTagNumber m_OtherValuesToLookFor;
		QuotationContentMask m_ContentMask;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ( <othervaluestolookfor:QuotationTagNumber> )\n"
			  << marge << "   <contentmask:QuotationContentMask>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class QuotationReplayL2Filter
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_OrderBookDepth);
		}

		QuotationReplayL2Filter() { reset(); }

		inline QuotationReplayL2Filter(QuotationReplayL2Filter const & c) :
			m_OrderBookDepth(c.m_OrderBookDepth)
		{}
		QuotationReplayL2Filter(int8 orderbookdepth) :
			m_OrderBookDepth(orderbookdepth)
		{}

		QuotationReplayL2Filter const & operator =(QuotationReplayL2Filter const & c)
		{
			m_OrderBookDepth = c.m_OrderBookDepth;
			return *this;
		}

		bool operator ==(QuotationReplayL2Filter const & c) const
		{
			return (m_OrderBookDepth == c.m_OrderBookDepth);
		}

	public:
		int8 getOrderBookDepth() const { return m_OrderBookDepth; }
		int8 & getOrderBookDepth() { return m_OrderBookDepth; }

	public:
		void setOrderBookDepth(int8 orderbookdepth) { m_OrderBookDepth = orderbookdepth; }

	protected:
		int8 m_OrderBookDepth;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <orderbookdepth:int8>\n"
			  << marge << " }\n";
		}
};

/**

		
*/
class ServerProperty
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Key);
			init_feedos_type (m_Value);
		}

		ServerProperty() { reset(); }

		inline ServerProperty(ServerProperty const & c) :
			m_Key(c.m_Key),
			m_Value(c.m_Value)
		{}
		ServerProperty(String const & key, BinaryBuffer value) :
			m_Key(key),
			m_Value(value)
		{}

		ServerProperty const & operator =(ServerProperty const & c)
		{
			m_Key = c.m_Key;
			m_Value = c.m_Value;
			return *this;
		}

		bool operator ==(ServerProperty const & c) const
		{
			return (m_Key == c.m_Key) && (m_Value == c.m_Value);
		}

	public:
		String const & getKey() const { return m_Key; }
		String & getKey() { return m_Key; }
		BinaryBuffer getValue() const { return m_Value; }
		BinaryBuffer & getValue() { return m_Value; }

	public:
		void setKey(String const & key) { m_Key = key; }
		void setValue(BinaryBuffer value) { m_Value = value; }

	protected:
		String m_Key;
		BinaryBuffer m_Value;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <key:String>\n"
			  << marge << "   <value:BinaryBuffer>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<ServerProperty> ListOfServerProperty;

/**
Internal ID of a feed
*/
typedef uint16 FeedInternalSourceID;

typedef std::vector<FeedInternalSourceID> ListOfFeedInternalSourceID;

/**

			tells about quality and speed of Market Data
		
*/
class FeedUsability
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_State);
			init_feedos_type (m_LatencyPenalty);
			init_feedos_type (m_OutOfDateValues);
			init_feedos_type (m_BadDataQuality);
		}

		FeedUsability() { reset(); }

		inline FeedUsability(FeedUsability const & c) :
			m_State(c.m_State),
			m_LatencyPenalty(c.m_LatencyPenalty),
			m_OutOfDateValues(c.m_OutOfDateValues),
			m_BadDataQuality(c.m_BadDataQuality)
		{}
		FeedUsability(FeedState state, bool latencypenalty, bool outofdatevalues, bool baddataquality) :
			m_State(state),
			m_LatencyPenalty(latencypenalty),
			m_OutOfDateValues(outofdatevalues),
			m_BadDataQuality(baddataquality)
		{}

		FeedUsability const & operator =(FeedUsability const & c)
		{
			m_State = c.m_State;
			m_LatencyPenalty = c.m_LatencyPenalty;
			m_OutOfDateValues = c.m_OutOfDateValues;
			m_BadDataQuality = c.m_BadDataQuality;
			return *this;
		}

		bool operator ==(FeedUsability const & c) const
		{
			return (m_State == c.m_State) && (m_LatencyPenalty == c.m_LatencyPenalty) && (m_OutOfDateValues == c.m_OutOfDateValues) && (m_BadDataQuality == c.m_BadDataQuality);
		}

	public:
		FeedState getState() const { return m_State; }
		FeedState & getState() { return m_State; }
		bool getLatencyPenalty() const { return m_LatencyPenalty; }
		bool & getLatencyPenalty() { return m_LatencyPenalty; }
		bool getOutOfDateValues() const { return m_OutOfDateValues; }
		bool & getOutOfDateValues() { return m_OutOfDateValues; }
		bool getBadDataQuality() const { return m_BadDataQuality; }
		bool & getBadDataQuality() { return m_BadDataQuality; }

	public:
		void setState(FeedState state) { m_State = state; }
		void setLatencyPenalty(bool latencypenalty) { m_LatencyPenalty = latencypenalty; }
		void setOutOfDateValues(bool outofdatevalues) { m_OutOfDateValues = outofdatevalues; }
		void setBadDataQuality(bool baddataquality) { m_BadDataQuality = baddataquality; }

	protected:
		FeedState m_State;
		bool m_LatencyPenalty;
		bool m_OutOfDateValues;
		bool m_BadDataQuality;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <state:FeedState>\n"
			  << marge << "   <latencypenalty:bool>\n"
			  << marge << "   <outofdatevalues:bool>\n"
			  << marge << "   <baddataquality:bool>\n"
			  << marge << " }\n";
		}
};

/**

			identifies a market data feed
		
*/
class FeedDescription
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_FeedName);
			init_feedos_type (m_InternalSourceIDs);
		}

		FeedDescription() { reset(); }

		inline FeedDescription(FeedDescription const & c) :
			m_FeedName(c.m_FeedName),
			m_InternalSourceIDs(c.m_InternalSourceIDs)
		{}
		FeedDescription(String const & feedname, ListOfFeedInternalSourceID const & internalsourceids) :
			m_FeedName(feedname),
			m_InternalSourceIDs(internalsourceids)
		{}

		FeedDescription const & operator =(FeedDescription const & c)
		{
			m_FeedName = c.m_FeedName;
			m_InternalSourceIDs = c.m_InternalSourceIDs;
			return *this;
		}

		bool operator ==(FeedDescription const & c) const
		{
			return (m_FeedName == c.m_FeedName) && (m_InternalSourceIDs == c.m_InternalSourceIDs);
		}

	public:
		String const & getFeedName() const { return m_FeedName; }
		String & getFeedName() { return m_FeedName; }
		ListOfFeedInternalSourceID const & getInternalSourceIDs() const { return m_InternalSourceIDs; }
		ListOfFeedInternalSourceID & getInternalSourceIDs() { return m_InternalSourceIDs; }

	public:
		void setFeedName(String const & feedname) { m_FeedName = feedname; }
		void setInternalSourceIDs(ListOfFeedInternalSourceID const & internalsourceids) { m_InternalSourceIDs = internalsourceids; }
		inline void swapInternalSourceIDs(ListOfFeedInternalSourceID & internalsourceids) { m_InternalSourceIDs.swap(internalsourceids); }

	protected:
		String m_FeedName;
		ListOfFeedInternalSourceID m_InternalSourceIDs;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <feedname:String>\n"
			  << marge << "   ( <internalsourceids:FeedInternalSourceID> )\n"
			  << marge << " }\n";
		}
};

typedef std::vector<FeedDescription> ListOfFeedDescription;

/**

			gives status of a given Market Data service
		
*/
class FeedServiceStatus
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ServiceName);
			init_feedos_type (m_Usability);
		}

		FeedServiceStatus() { reset(); }

		inline FeedServiceStatus(FeedServiceStatus const & c) :
			m_ServiceName(c.m_ServiceName),
			m_Usability(c.m_Usability)
		{}
		FeedServiceStatus(String const & servicename, FeedUsability const & usability) :
			m_ServiceName(servicename),
			m_Usability(usability)
		{}

		FeedServiceStatus const & operator =(FeedServiceStatus const & c)
		{
			m_ServiceName = c.m_ServiceName;
			m_Usability = c.m_Usability;
			return *this;
		}

		bool operator ==(FeedServiceStatus const & c) const
		{
			return (m_ServiceName == c.m_ServiceName) && (m_Usability == c.m_Usability);
		}

	public:
		String const & getServiceName() const { return m_ServiceName; }
		String & getServiceName() { return m_ServiceName; }
		FeedUsability const & getUsability() const { return m_Usability; }
		FeedUsability & getUsability() { return m_Usability; }

	public:
		void setServiceName(String const & servicename) { m_ServiceName = servicename; }
		void setUsability(FeedUsability const & usability) { m_Usability = usability; }

	protected:
		String m_ServiceName;
		FeedUsability m_Usability;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <servicename:String>\n"
			  << marge << "   ";
			FeedUsability::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<FeedServiceStatus> ListOfFeedServiceStatus;

/**

			gives status of a whole feed
		
*/
class FeedStatus
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Feed);
			init_feedos_type (m_OverallUsability);
			init_feedos_type (m_Services);
		}

		FeedStatus() { reset(); }

		inline FeedStatus(FeedStatus const & c) :
			m_Feed(c.m_Feed),
			m_OverallUsability(c.m_OverallUsability),
			m_Services(c.m_Services)
		{}
		FeedStatus(FeedDescription const & feed, FeedUsability const & overallusability, ListOfFeedServiceStatus const & services) :
			m_Feed(feed),
			m_OverallUsability(overallusability),
			m_Services(services)
		{}

		FeedStatus const & operator =(FeedStatus const & c)
		{
			m_Feed = c.m_Feed;
			m_OverallUsability = c.m_OverallUsability;
			m_Services = c.m_Services;
			return *this;
		}

		bool operator ==(FeedStatus const & c) const
		{
			return (m_Feed == c.m_Feed) && (m_OverallUsability == c.m_OverallUsability) && (m_Services == c.m_Services);
		}

	public:
		FeedDescription const & getFeed() const { return m_Feed; }
		FeedDescription & getFeed() { return m_Feed; }
		FeedUsability const & getOverallUsability() const { return m_OverallUsability; }
		FeedUsability & getOverallUsability() { return m_OverallUsability; }
		ListOfFeedServiceStatus const & getServices() const { return m_Services; }
		ListOfFeedServiceStatus & getServices() { return m_Services; }

	public:
		void setFeed(FeedDescription const & feed) { m_Feed = feed; }
		void setOverallUsability(FeedUsability const & overallusability) { m_OverallUsability = overallusability; }
		void setServices(ListOfFeedServiceStatus const & services) { m_Services = services; }
		inline void swapServices(ListOfFeedServiceStatus & services) { m_Services.swap(services); }

	protected:
		FeedDescription m_Feed;
		FeedUsability m_OverallUsability;
		ListOfFeedServiceStatus m_Services;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			FeedDescription::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ";
			FeedUsability::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ( <services:FeedServiceStatus> )\n";
			FeedServiceStatus::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<FeedStatus> ListOfFeedStatus;

/**

			an event related to a given feed
		
*/
class FeedStatusEvent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Feed);
			init_feedos_type (m_EventType);
			init_feedos_type (m_EventDetails);
		}

		FeedStatusEvent() { reset(); }

		inline FeedStatusEvent(FeedStatusEvent const & c) :
			m_Feed(c.m_Feed),
			m_EventType(c.m_EventType),
			m_EventDetails(c.m_EventDetails)
		{}
		FeedStatusEvent(FeedDescription const & feed, String const & eventtype, ListOfString const & eventdetails) :
			m_Feed(feed),
			m_EventType(eventtype),
			m_EventDetails(eventdetails)
		{}

		FeedStatusEvent const & operator =(FeedStatusEvent const & c)
		{
			m_Feed = c.m_Feed;
			m_EventType = c.m_EventType;
			m_EventDetails = c.m_EventDetails;
			return *this;
		}

		bool operator ==(FeedStatusEvent const & c) const
		{
			return (m_Feed == c.m_Feed) && (m_EventType == c.m_EventType) && (m_EventDetails == c.m_EventDetails);
		}

	public:
		FeedDescription const & getFeed() const { return m_Feed; }
		FeedDescription & getFeed() { return m_Feed; }
		String const & getEventType() const { return m_EventType; }
		String & getEventType() { return m_EventType; }
		ListOfString const & getEventDetails() const { return m_EventDetails; }
		ListOfString & getEventDetails() { return m_EventDetails; }

	public:
		void setFeed(FeedDescription const & feed) { m_Feed = feed; }
		void setEventType(String const & eventtype) { m_EventType = eventtype; }
		void setEventDetails(ListOfString const & eventdetails) { m_EventDetails = eventdetails; }
		inline void swapEventDetails(ListOfString & eventdetails) { m_EventDetails.swap(eventdetails); }

	protected:
		FeedDescription m_Feed;
		String m_EventType;
		ListOfString m_EventDetails;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			FeedDescription::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <eventtype:String>\n"
			  << marge << "   ( <eventdetails:String> )\n"
			  << marge << " }\n";
		}
};

/**

			gives status of a whole feed
		
*/
class FeedHandlerConfiguration
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Feed);
			init_feedos_type (m_Role);
			init_feedos_type (m_OwnServerName);
			init_feedos_type (m_PeerServerName);
			init_feedos_type (m_DataRateMeasureHz);
		}

		FeedHandlerConfiguration() { reset(); }

		inline FeedHandlerConfiguration(FeedHandlerConfiguration const & c) :
			m_Feed(c.m_Feed),
			m_Role(c.m_Role),
			m_OwnServerName(c.m_OwnServerName),
			m_PeerServerName(c.m_PeerServerName),
			m_DataRateMeasureHz(c.m_DataRateMeasureHz)
		{}
		FeedHandlerConfiguration(FeedDescription const & feed, FeedHandlerResiliencyRole role, String const & ownservername, String const & peerservername, float64 dataratemeasurehz) :
			m_Feed(feed),
			m_Role(role),
			m_OwnServerName(ownservername),
			m_PeerServerName(peerservername),
			m_DataRateMeasureHz(dataratemeasurehz)
		{}

		FeedHandlerConfiguration const & operator =(FeedHandlerConfiguration const & c)
		{
			m_Feed = c.m_Feed;
			m_Role = c.m_Role;
			m_OwnServerName = c.m_OwnServerName;
			m_PeerServerName = c.m_PeerServerName;
			m_DataRateMeasureHz = c.m_DataRateMeasureHz;
			return *this;
		}

		bool operator ==(FeedHandlerConfiguration const & c) const
		{
			return (m_Feed == c.m_Feed) && (m_Role == c.m_Role) && (m_OwnServerName == c.m_OwnServerName) && (m_PeerServerName == c.m_PeerServerName) && (m_DataRateMeasureHz == c.m_DataRateMeasureHz);
		}

	public:
		FeedDescription const & getFeed() const { return m_Feed; }
		FeedDescription & getFeed() { return m_Feed; }
		FeedHandlerResiliencyRole getRole() const { return m_Role; }
		FeedHandlerResiliencyRole & getRole() { return m_Role; }
		String const & getOwnServerName() const { return m_OwnServerName; }
		String & getOwnServerName() { return m_OwnServerName; }
		String const & getPeerServerName() const { return m_PeerServerName; }
		String & getPeerServerName() { return m_PeerServerName; }
		float64 getDataRateMeasureHz() const { return m_DataRateMeasureHz; }
		float64 & getDataRateMeasureHz() { return m_DataRateMeasureHz; }

	public:
		void setFeed(FeedDescription const & feed) { m_Feed = feed; }
		void setRole(FeedHandlerResiliencyRole role) { m_Role = role; }
		void setOwnServerName(String const & ownservername) { m_OwnServerName = ownservername; }
		void setPeerServerName(String const & peerservername) { m_PeerServerName = peerservername; }
		void setDataRateMeasureHz(float64 dataratemeasurehz) { m_DataRateMeasureHz = dataratemeasurehz; }

	protected:
		FeedDescription m_Feed;
		FeedHandlerResiliencyRole m_Role;
		String m_OwnServerName;
		String m_PeerServerName;
		float64 m_DataRateMeasureHz;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { ";
			FeedDescription::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <role:FeedHandlerResiliencyRole>\n"
			  << marge << "   <ownservername:String>\n"
			  << marge << "   <peerservername:String>\n"
			  << marge << "   <dataratemeasurehz:float64>\n"
			  << marge << " }\n";
		}
};

/**

			gives statistics about data rates (input or output)
		
*/
class FeedHandlerDataRate
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_DataName);
			init_feedos_type (m_InstantRateHz);
		}

		FeedHandlerDataRate() { reset(); }

		inline FeedHandlerDataRate(FeedHandlerDataRate const & c) :
			m_DataName(c.m_DataName),
			m_InstantRateHz(c.m_InstantRateHz)
		{}
		FeedHandlerDataRate(String const & dataname, float64 instantratehz) :
			m_DataName(dataname),
			m_InstantRateHz(instantratehz)
		{}

		FeedHandlerDataRate const & operator =(FeedHandlerDataRate const & c)
		{
			m_DataName = c.m_DataName;
			m_InstantRateHz = c.m_InstantRateHz;
			return *this;
		}

		bool operator ==(FeedHandlerDataRate const & c) const
		{
			return (m_DataName == c.m_DataName) && (m_InstantRateHz == c.m_InstantRateHz);
		}

	public:
		String const & getDataName() const { return m_DataName; }
		String & getDataName() { return m_DataName; }
		float64 getInstantRateHz() const { return m_InstantRateHz; }
		float64 & getInstantRateHz() { return m_InstantRateHz; }

	public:
		void setDataName(String const & dataname) { m_DataName = dataname; }
		void setInstantRateHz(float64 instantratehz) { m_InstantRateHz = instantratehz; }

	protected:
		String m_DataName;
		float64 m_InstantRateHz;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <dataname:String>\n"
			  << marge << "   <instantratehz:float64>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<FeedHandlerDataRate> ListOfFeedHandlerDataRate;

/**

			gives statistics about data rates (input or output)
		
*/
class FeedHandlerState
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ResiliencyStatus);
			init_feedos_type (m_InputRate);
			init_feedos_type (m_OutputRate);
		}

		FeedHandlerState() { reset(); }

		inline FeedHandlerState(FeedHandlerState const & c) :
			m_ResiliencyStatus(c.m_ResiliencyStatus),
			m_InputRate(c.m_InputRate),
			m_OutputRate(c.m_OutputRate)
		{}
		FeedHandlerState(FeedHandlerResiliencyStatus resiliencystatus, ListOfFeedHandlerDataRate const & inputrate, ListOfFeedHandlerDataRate const & outputrate) :
			m_ResiliencyStatus(resiliencystatus),
			m_InputRate(inputrate),
			m_OutputRate(outputrate)
		{}

		FeedHandlerState const & operator =(FeedHandlerState const & c)
		{
			m_ResiliencyStatus = c.m_ResiliencyStatus;
			m_InputRate = c.m_InputRate;
			m_OutputRate = c.m_OutputRate;
			return *this;
		}

		bool operator ==(FeedHandlerState const & c) const
		{
			return (m_ResiliencyStatus == c.m_ResiliencyStatus) && (m_InputRate == c.m_InputRate) && (m_OutputRate == c.m_OutputRate);
		}

	public:
		FeedHandlerResiliencyStatus getResiliencyStatus() const { return m_ResiliencyStatus; }
		FeedHandlerResiliencyStatus & getResiliencyStatus() { return m_ResiliencyStatus; }
		ListOfFeedHandlerDataRate const & getInputRate() const { return m_InputRate; }
		ListOfFeedHandlerDataRate & getInputRate() { return m_InputRate; }
		ListOfFeedHandlerDataRate const & getOutputRate() const { return m_OutputRate; }
		ListOfFeedHandlerDataRate & getOutputRate() { return m_OutputRate; }

	public:
		void setResiliencyStatus(FeedHandlerResiliencyStatus resiliencystatus) { m_ResiliencyStatus = resiliencystatus; }
		void setInputRate(ListOfFeedHandlerDataRate const & inputrate) { m_InputRate = inputrate; }
		inline void swapInputRate(ListOfFeedHandlerDataRate & inputrate) { m_InputRate.swap(inputrate); }
		void setOutputRate(ListOfFeedHandlerDataRate const & outputrate) { m_OutputRate = outputrate; }
		inline void swapOutputRate(ListOfFeedHandlerDataRate & outputrate) { m_OutputRate.swap(outputrate); }

	protected:
		FeedHandlerResiliencyStatus m_ResiliencyStatus;
		ListOfFeedHandlerDataRate m_InputRate;
		ListOfFeedHandlerDataRate m_OutputRate;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <resiliencystatus:FeedHandlerResiliencyStatus>\n"
			  << marge << "   ( <inputrate:FeedHandlerDataRate> )\n";
			FeedHandlerDataRate::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << "   ( <outputrate:FeedHandlerDataRate> )\n";
			FeedHandlerDataRate::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

/**

			status of a proxy: name, description and last ReturnCode (RC_OK,RC_DISCONNECTED,RC_UA_INVALID_NAME_OR_PASSWORD,etc)
		
*/
class ProxyStatus
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Name);
			init_feedos_type (m_RemoteAddress);
			init_feedos_type (m_Description);
			init_feedos_type (m_IsAvailable);
		}

		ProxyStatus() { reset(); }

		inline ProxyStatus(ProxyStatus const & c) :
			m_Name(c.m_Name),
			m_RemoteAddress(c.m_RemoteAddress),
			m_Description(c.m_Description),
			m_IsAvailable(c.m_IsAvailable)
		{}
		ProxyStatus(String const & name, String const & remoteaddress, String const & description, bool isavailable) :
			m_Name(name),
			m_RemoteAddress(remoteaddress),
			m_Description(description),
			m_IsAvailable(isavailable)
		{}

		ProxyStatus const & operator =(ProxyStatus const & c)
		{
			m_Name = c.m_Name;
			m_RemoteAddress = c.m_RemoteAddress;
			m_Description = c.m_Description;
			m_IsAvailable = c.m_IsAvailable;
			return *this;
		}

		bool operator ==(ProxyStatus const & c) const
		{
			return (m_Name == c.m_Name) && (m_RemoteAddress == c.m_RemoteAddress) && (m_Description == c.m_Description) && (m_IsAvailable == c.m_IsAvailable);
		}

	public:
		String const & getName() const { return m_Name; }
		String & getName() { return m_Name; }
		String const & getRemoteAddress() const { return m_RemoteAddress; }
		String & getRemoteAddress() { return m_RemoteAddress; }
		String const & getDescription() const { return m_Description; }
		String & getDescription() { return m_Description; }
		bool getIsAvailable() const { return m_IsAvailable; }
		bool & getIsAvailable() { return m_IsAvailable; }

	public:
		void setName(String const & name) { m_Name = name; }
		void setRemoteAddress(String const & remoteaddress) { m_RemoteAddress = remoteaddress; }
		void setDescription(String const & description) { m_Description = description; }
		void setIsAvailable(bool isavailable) { m_IsAvailable = isavailable; }

	protected:
		String m_Name;
		String m_RemoteAddress;
		String m_Description;
		bool m_IsAvailable;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <name:String>\n"
			  << marge << "   <remoteaddress:String>\n"
			  << marge << "   <description:String>\n"
			  << marge << "   <isavailable:bool>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<ProxyStatus> ListOfProxyStatus;

/**

			metadata: definition of a tag
		
*/
class TagDeclaration
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_TagUsage);
			init_feedos_type (m_TagSyntax);
			init_feedos_type (m_TagNumericId);
			init_feedos_type (m_TagName);
			init_feedos_type (m_TagDescription);
		}

		TagDeclaration() { reset(); }

		inline TagDeclaration(TagDeclaration const & c) :
			m_TagUsage(c.m_TagUsage),
			m_TagSyntax(c.m_TagSyntax),
			m_TagNumericId(c.m_TagNumericId),
			m_TagName(c.m_TagName),
			m_TagDescription(c.m_TagDescription)
		{}
		TagDeclaration(String const & tagusage, Enum tagsyntax, TagNumber tagnumericid, String const & tagname, String const & tagdescription) :
			m_TagUsage(tagusage),
			m_TagSyntax(tagsyntax),
			m_TagNumericId(tagnumericid),
			m_TagName(tagname),
			m_TagDescription(tagdescription)
		{}

		TagDeclaration const & operator =(TagDeclaration const & c)
		{
			m_TagUsage = c.m_TagUsage;
			m_TagSyntax = c.m_TagSyntax;
			m_TagNumericId = c.m_TagNumericId;
			m_TagName = c.m_TagName;
			m_TagDescription = c.m_TagDescription;
			return *this;
		}

		bool operator ==(TagDeclaration const & c) const
		{
			return (m_TagUsage == c.m_TagUsage) && (m_TagSyntax == c.m_TagSyntax) && (m_TagNumericId == c.m_TagNumericId) && (m_TagName == c.m_TagName) && (m_TagDescription == c.m_TagDescription);
		}

	public:
		String const & getTagUsage() const { return m_TagUsage; }
		String & getTagUsage() { return m_TagUsage; }
		Enum getTagSyntax() const { return m_TagSyntax; }
		Enum & getTagSyntax() { return m_TagSyntax; }
		TagNumber getTagNumericId() const { return m_TagNumericId; }
		TagNumber & getTagNumericId() { return m_TagNumericId; }
		String const & getTagName() const { return m_TagName; }
		String & getTagName() { return m_TagName; }
		String const & getTagDescription() const { return m_TagDescription; }
		String & getTagDescription() { return m_TagDescription; }

	public:
		void setTagUsage(String const & tagusage) { m_TagUsage = tagusage; }
		void setTagSyntax(Enum tagsyntax) { m_TagSyntax = tagsyntax; }
		void setTagNumericId(TagNumber tagnumericid) { m_TagNumericId = tagnumericid; }
		void setTagName(String const & tagname) { m_TagName = tagname; }
		void setTagDescription(String const & tagdescription) { m_TagDescription = tagdescription; }

	protected:
		String m_TagUsage;
		Enum m_TagSyntax;
		TagNumber m_TagNumericId;
		String m_TagName;
		String m_TagDescription;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <tagusage:String>\n"
			  << marge << "   <tagsyntax:Enum>\n"
			  << marge << "   <tagnumericid:TagNumber>\n"
			  << marge << "   <tagname:String>\n"
			  << marge << "   <tagdescription:String>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<TagDeclaration> ListOfTagDeclaration;

/**

			metadata: definition of an Enum value
		
*/
class EnumValueDeclaration
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Value);
			init_feedos_type (m_ValueName);
			init_feedos_type (m_ValueDescription);
		}

		EnumValueDeclaration() { reset(); }

		inline EnumValueDeclaration(EnumValueDeclaration const & c) :
			m_Value(c.m_Value),
			m_ValueName(c.m_ValueName),
			m_ValueDescription(c.m_ValueDescription)
		{}
		EnumValueDeclaration(Any const & value, String const & valuename, String const & valuedescription) :
			m_Value(value),
			m_ValueName(valuename),
			m_ValueDescription(valuedescription)
		{}

		EnumValueDeclaration const & operator =(EnumValueDeclaration const & c)
		{
			m_Value = c.m_Value;
			m_ValueName = c.m_ValueName;
			m_ValueDescription = c.m_ValueDescription;
			return *this;
		}

		bool operator ==(EnumValueDeclaration const & c) const
		{
			return (m_Value == c.m_Value) && (m_ValueName == c.m_ValueName) && (m_ValueDescription == c.m_ValueDescription);
		}

	public:
		Any const & getValue() const { return m_Value; }
		Any & getValue() { return m_Value; }
		String const & getValueName() const { return m_ValueName; }
		String & getValueName() { return m_ValueName; }
		String const & getValueDescription() const { return m_ValueDescription; }
		String & getValueDescription() { return m_ValueDescription; }

	public:
		void setValue(Any const & value) { m_Value = value; }
		void setValueName(String const & valuename) { m_ValueName = valuename; }
		void setValueDescription(String const & valuedescription) { m_ValueDescription = valuedescription; }

	protected:
		Any m_Value;
		String m_ValueName;
		String m_ValueDescription;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <value:Any>\n"
			  << marge << "   <valuename:String>\n"
			  << marge << "   <valuedescription:String>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<EnumValueDeclaration> ListOfEnumValueDeclaration;

/**

			metadata: definition of a Enum type and its values
		
*/
class EnumTypeDeclaration
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_EnumName);
			init_feedos_type (m_EnumDescription);
			init_feedos_type (m_RelatedTags);
			init_feedos_type (m_EnumValues);
		}

		EnumTypeDeclaration() { reset(); }

		inline EnumTypeDeclaration(EnumTypeDeclaration const & c) :
			m_EnumName(c.m_EnumName),
			m_EnumDescription(c.m_EnumDescription),
			m_RelatedTags(c.m_RelatedTags),
			m_EnumValues(c.m_EnumValues)
		{}
		EnumTypeDeclaration(String const & enumname, String const & enumdescription, ListOfTagNumber const & relatedtags, ListOfEnumValueDeclaration const & enumvalues) :
			m_EnumName(enumname),
			m_EnumDescription(enumdescription),
			m_RelatedTags(relatedtags),
			m_EnumValues(enumvalues)
		{}

		EnumTypeDeclaration const & operator =(EnumTypeDeclaration const & c)
		{
			m_EnumName = c.m_EnumName;
			m_EnumDescription = c.m_EnumDescription;
			m_RelatedTags = c.m_RelatedTags;
			m_EnumValues = c.m_EnumValues;
			return *this;
		}

		bool operator ==(EnumTypeDeclaration const & c) const
		{
			return (m_EnumName == c.m_EnumName) && (m_EnumDescription == c.m_EnumDescription) && (m_RelatedTags == c.m_RelatedTags) && (m_EnumValues == c.m_EnumValues);
		}

	public:
		String const & getEnumName() const { return m_EnumName; }
		String & getEnumName() { return m_EnumName; }
		String const & getEnumDescription() const { return m_EnumDescription; }
		String & getEnumDescription() { return m_EnumDescription; }
		ListOfTagNumber const & getRelatedTags() const { return m_RelatedTags; }
		ListOfTagNumber & getRelatedTags() { return m_RelatedTags; }
		ListOfEnumValueDeclaration const & getEnumValues() const { return m_EnumValues; }
		ListOfEnumValueDeclaration & getEnumValues() { return m_EnumValues; }

	public:
		void setEnumName(String const & enumname) { m_EnumName = enumname; }
		void setEnumDescription(String const & enumdescription) { m_EnumDescription = enumdescription; }
		void setRelatedTags(ListOfTagNumber const & relatedtags) { m_RelatedTags = relatedtags; }
		inline void swapRelatedTags(ListOfTagNumber & relatedtags) { m_RelatedTags.swap(relatedtags); }
		void setEnumValues(ListOfEnumValueDeclaration const & enumvalues) { m_EnumValues = enumvalues; }
		inline void swapEnumValues(ListOfEnumValueDeclaration & enumvalues) { m_EnumValues.swap(enumvalues); }

	protected:
		String m_EnumName;
		String m_EnumDescription;
		ListOfTagNumber m_RelatedTags;
		ListOfEnumValueDeclaration m_EnumValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <enumname:String>\n"
			  << marge << "   <enumdescription:String>\n"
			  << marge << "   ( <relatedtags:TagNumber> )\n"
			  << marge << "   ( <enumvalues:EnumValueDeclaration> )\n";
			EnumValueDeclaration::dump_usage(o,marge+std::string("      "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<EnumTypeDeclaration> ListOfEnumTypeDeclaration;

/**

			Identifies a client connection on a subscription server
		
*/
class UserConnectionInfo
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_UserId);
			init_feedos_type (m_UserName);
			init_feedos_type (m_ClientId);
			init_feedos_type (m_ConnectionId);
			init_feedos_type (m_Timestamp);
		}

		UserConnectionInfo() { reset(); }

		inline UserConnectionInfo(UserConnectionInfo const & c) :
			m_UserId(c.m_UserId),
			m_UserName(c.m_UserName),
			m_ClientId(c.m_ClientId),
			m_ConnectionId(c.m_ConnectionId),
			m_Timestamp(c.m_Timestamp)
		{}
		UserConnectionInfo(UserId userid, String const & username, uint32 clientid, String const & connectionid, Timestamp const & timestamp) :
			m_UserId(userid),
			m_UserName(username),
			m_ClientId(clientid),
			m_ConnectionId(connectionid),
			m_Timestamp(timestamp)
		{}

		UserConnectionInfo const & operator =(UserConnectionInfo const & c)
		{
			m_UserId = c.m_UserId;
			m_UserName = c.m_UserName;
			m_ClientId = c.m_ClientId;
			m_ConnectionId = c.m_ConnectionId;
			m_Timestamp = c.m_Timestamp;
			return *this;
		}

		bool operator ==(UserConnectionInfo const & c) const
		{
			return (m_UserId == c.m_UserId) && (m_UserName == c.m_UserName) && (m_ClientId == c.m_ClientId) && (m_ConnectionId == c.m_ConnectionId) && (m_Timestamp == c.m_Timestamp);
		}

	public:
		UserId getUserId() const { return m_UserId; }
		UserId & getUserId() { return m_UserId; }
		String const & getUserName() const { return m_UserName; }
		String & getUserName() { return m_UserName; }
		uint32 getClientId() const { return m_ClientId; }
		uint32 & getClientId() { return m_ClientId; }
		String const & getConnectionId() const { return m_ConnectionId; }
		String & getConnectionId() { return m_ConnectionId; }
		Timestamp const & getTimestamp() const { return m_Timestamp; }
		Timestamp & getTimestamp() { return m_Timestamp; }

	public:
		void setUserId(UserId userid) { m_UserId = userid; }
		void setUserName(String const & username) { m_UserName = username; }
		void setClientId(uint32 clientid) { m_ClientId = clientid; }
		void setConnectionId(String const & connectionid) { m_ConnectionId = connectionid; }
		void setTimestamp(Timestamp const & timestamp) { m_Timestamp = timestamp; }

	protected:
		UserId m_UserId;
		String m_UserName;
		uint32 m_ClientId;
		String m_ConnectionId;
		Timestamp m_Timestamp;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <userid:UserId>\n"
			  << marge << "   <username:String>\n"
			  << marge << "   <clientid:uint32>\n"
			  << marge << "   <connectionid:String>\n"
			  << marge << "   <timestamp:Timestamp>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<UserConnectionInfo> ListOfUserConnectionInfo;

typedef std::vector<AdjustmentFactorEventType> ListOfAdjustmentFactorEventType;

/**

			Contains value by which adjust (multiply or divide) prices and/or volumes prior to the execution date
			along with information on the corporate action leading to this adjustment.
			AdjustmentFactorEvent have a unique (Code, EventDay, EventType, KeySuffix).
			Canceled events must not be used for adjusting.
			Canceled events are stored because cancelation can be canceled, and for tracking.
		
*/
class AdjustmentFactorEvent
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Code);
			init_feedos_type (m_EventDay);
			init_feedos_type (m_EventType);
			init_feedos_type (m_KeySuffix);
			init_feedos_type (m_Factor);
			init_feedos_type (m_Canceled);
			init_feedos_type (m_MIC);
			init_feedos_type (m_Ticker);
			init_feedos_type (m_Details);
		}

		AdjustmentFactorEvent() { reset(); }

		inline AdjustmentFactorEvent(AdjustmentFactorEvent const & c) :
			m_Code(c.m_Code),
			m_EventDay(c.m_EventDay),
			m_EventType(c.m_EventType),
			m_KeySuffix(c.m_KeySuffix),
			m_Factor(c.m_Factor),
			m_Canceled(c.m_Canceled),
			m_MIC(c.m_MIC),
			m_Ticker(c.m_Ticker),
			m_Details(c.m_Details)
		{}
		AdjustmentFactorEvent(FOSInstrumentCode code, Timestamp const & eventday, AdjustmentFactorEventType eventtype, uint16 keysuffix, float64 factor, bool canceled, String const & mic, String const & ticker, String const & details) :
			m_Code(code),
			m_EventDay(eventday),
			m_EventType(eventtype),
			m_KeySuffix(keysuffix),
			m_Factor(factor),
			m_Canceled(canceled),
			m_MIC(mic),
			m_Ticker(ticker),
			m_Details(details)
		{}

		AdjustmentFactorEvent const & operator =(AdjustmentFactorEvent const & c)
		{
			m_Code = c.m_Code;
			m_EventDay = c.m_EventDay;
			m_EventType = c.m_EventType;
			m_KeySuffix = c.m_KeySuffix;
			m_Factor = c.m_Factor;
			m_Canceled = c.m_Canceled;
			m_MIC = c.m_MIC;
			m_Ticker = c.m_Ticker;
			m_Details = c.m_Details;
			return *this;
		}

		bool operator ==(AdjustmentFactorEvent const & c) const
		{
			return (m_Code == c.m_Code) && (m_EventDay == c.m_EventDay) && (m_EventType == c.m_EventType) && (m_KeySuffix == c.m_KeySuffix) && (m_Factor == c.m_Factor) && (m_Canceled == c.m_Canceled) && (m_MIC == c.m_MIC) && (m_Ticker == c.m_Ticker) && (m_Details == c.m_Details);
		}

	public:
		FOSInstrumentCode getCode() const { return m_Code; }
		FOSInstrumentCode & getCode() { return m_Code; }
		Timestamp const & getEventDay() const { return m_EventDay; }
		Timestamp & getEventDay() { return m_EventDay; }
		AdjustmentFactorEventType getEventType() const { return m_EventType; }
		AdjustmentFactorEventType & getEventType() { return m_EventType; }
		uint16 getKeySuffix() const { return m_KeySuffix; }
		uint16 & getKeySuffix() { return m_KeySuffix; }
		float64 getFactor() const { return m_Factor; }
		float64 & getFactor() { return m_Factor; }
		bool getCanceled() const { return m_Canceled; }
		bool & getCanceled() { return m_Canceled; }
		String const & getMIC() const { return m_MIC; }
		String & getMIC() { return m_MIC; }
		String const & getTicker() const { return m_Ticker; }
		String & getTicker() { return m_Ticker; }
		String const & getDetails() const { return m_Details; }
		String & getDetails() { return m_Details; }

	public:
		void setCode(FOSInstrumentCode code) { m_Code = code; }
		void setEventDay(Timestamp const & eventday) { m_EventDay = eventday; }
		void setEventType(AdjustmentFactorEventType eventtype) { m_EventType = eventtype; }
		void setKeySuffix(uint16 keysuffix) { m_KeySuffix = keysuffix; }
		void setFactor(float64 factor) { m_Factor = factor; }
		void setCanceled(bool canceled) { m_Canceled = canceled; }
		void setMIC(String const & mic) { m_MIC = mic; }
		void setTicker(String const & ticker) { m_Ticker = ticker; }
		void setDetails(String const & details) { m_Details = details; }

	protected:
		FOSInstrumentCode m_Code;
		Timestamp m_EventDay;
		AdjustmentFactorEventType m_EventType;
		uint16 m_KeySuffix;
		float64 m_Factor;
		bool m_Canceled;
		String m_MIC;
		String m_Ticker;
		String m_Details;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <code:FOSInstrumentCode>\n"
			  << marge << "   <eventday:Timestamp>\n"
			  << marge << "   <eventtype:AdjustmentFactorEventType>\n"
			  << marge << "   <keysuffix:uint16>\n"
			  << marge << "   <factor:float64>\n"
			  << marge << "   <canceled:bool>\n"
			  << marge << "   <mic:String>\n"
			  << marge << "   <ticker:String>\n"
			  << marge << "   <details:String>\n"
			  << marge << " }\n";
		}
};

typedef std::vector<AdjustmentFactorEvent> ListOfAdjustmentFactorEvent;

/**

			bit-wise combinations of (1 SHL X) values, where X belongs to enum AdjustmentFactorEventType.
		
*/
typedef uint32 AdjustmentFactorEventTypeMask;

/**

			bit-wise combination of (1 SHL X) values, where X belongs to enum TradeCancelCorrectionContent
		
*/
typedef uint8 TradeCancelCorrectionContentMask;

/**

			Data related to a trade used for cancel/correction
		
*/
class TradeData
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_Price);
			init_feedos_type (m_Quantity);
			init_feedos_type (m_TradeImpactIndicator);
			init_feedos_type (m_MarketTimestamp);
			init_feedos_type (m_TradeId);
			init_feedos_type (m_TradeProperties);
		}

		TradeData() { reset(); }

		inline TradeData(TradeData const & c) :
			m_Price(c.m_Price),
			m_Quantity(c.m_Quantity),
			m_TradeImpactIndicator(c.m_TradeImpactIndicator),
			m_MarketTimestamp(c.m_MarketTimestamp),
			m_TradeId(c.m_TradeId),
			m_TradeProperties(c.m_TradeProperties)
		{}
		TradeData(float64 price, float64 quantity, QuotationTradeImpactIndicatorMask tradeimpactindicator, Timestamp const & markettimestamp, Any const & tradeid, ListOfQuotationVariable const & tradeproperties) :
			m_Price(price),
			m_Quantity(quantity),
			m_TradeImpactIndicator(tradeimpactindicator),
			m_MarketTimestamp(markettimestamp),
			m_TradeId(tradeid),
			m_TradeProperties(tradeproperties)
		{}

		TradeData const & operator =(TradeData const & c)
		{
			m_Price = c.m_Price;
			m_Quantity = c.m_Quantity;
			m_TradeImpactIndicator = c.m_TradeImpactIndicator;
			m_MarketTimestamp = c.m_MarketTimestamp;
			m_TradeId = c.m_TradeId;
			m_TradeProperties = c.m_TradeProperties;
			return *this;
		}

		bool operator ==(TradeData const & c) const
		{
			return (m_Price == c.m_Price) && (m_Quantity == c.m_Quantity) && (m_TradeImpactIndicator == c.m_TradeImpactIndicator) && (m_MarketTimestamp == c.m_MarketTimestamp) && (m_TradeId == c.m_TradeId) && (m_TradeProperties == c.m_TradeProperties);
		}

	public:
		float64 getPrice() const { return m_Price; }
		float64 & getPrice() { return m_Price; }
		float64 getQuantity() const { return m_Quantity; }
		float64 & getQuantity() { return m_Quantity; }
		QuotationTradeImpactIndicatorMask getTradeImpactIndicator() const { return m_TradeImpactIndicator; }
		QuotationTradeImpactIndicatorMask & getTradeImpactIndicator() { return m_TradeImpactIndicator; }
		Timestamp const & getMarketTimestamp() const { return m_MarketTimestamp; }
		Timestamp & getMarketTimestamp() { return m_MarketTimestamp; }
		Any const & getTradeId() const { return m_TradeId; }
		Any & getTradeId() { return m_TradeId; }
		ListOfQuotationVariable const & getTradeProperties() const { return m_TradeProperties; }
		ListOfQuotationVariable & getTradeProperties() { return m_TradeProperties; }

	public:
		void setPrice(float64 price) { m_Price = price; }
		void setQuantity(float64 quantity) { m_Quantity = quantity; }
		void setTradeImpactIndicator(QuotationTradeImpactIndicatorMask tradeimpactindicator) { m_TradeImpactIndicator = tradeimpactindicator; }
		void setMarketTimestamp(Timestamp const & markettimestamp) { m_MarketTimestamp = markettimestamp; }
		void setTradeId(Any const & tradeid) { m_TradeId = tradeid; }
		void setTradeProperties(ListOfQuotationVariable const & tradeproperties) { m_TradeProperties = tradeproperties; }
		inline void swapTradeProperties(ListOfQuotationVariable & tradeproperties) { m_TradeProperties.swap(tradeproperties); }

	protected:
		float64 m_Price;
		float64 m_Quantity;
		QuotationTradeImpactIndicatorMask m_TradeImpactIndicator;
		Timestamp m_MarketTimestamp;
		Any m_TradeId;
		ListOfQuotationVariable m_TradeProperties;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <price:float64>\n"
			  << marge << "   <quantity:float64>\n"
			  << marge << "   <tradeimpactindicator:QuotationTradeImpactIndicatorMask>\n"
			  << marge << "   <markettimestamp:Timestamp>\n"
			  << marge << "   <tradeid:Any>\n"
			  << marge << "   ( <tradeproperties:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

/**

			trade cancel/correction data
		
*/
class QuotationTradeCancelCorrection
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_ContentMask);
			init_feedos_type (m_OriginalTrade);
			init_feedos_type (m_TradingSessionId);
			init_feedos_type (m_CorrectedTrade);
			init_feedos_type (m_CorrectedValues);
		}

		QuotationTradeCancelCorrection() { reset(); }

		inline QuotationTradeCancelCorrection(QuotationTradeCancelCorrection const & c) :
			m_ContentMask(c.m_ContentMask),
			m_OriginalTrade(c.m_OriginalTrade),
			m_TradingSessionId(c.m_TradingSessionId),
			m_CorrectedTrade(c.m_CorrectedTrade),
			m_CorrectedValues(c.m_CorrectedValues)
		{}
		QuotationTradeCancelCorrection(TradeCancelCorrectionContentMask contentmask, TradeData const & originaltrade, FOSTradingSessionId tradingsessionid, TradeData const & correctedtrade, ListOfQuotationVariable const & correctedvalues) :
			m_ContentMask(contentmask),
			m_OriginalTrade(originaltrade),
			m_TradingSessionId(tradingsessionid),
			m_CorrectedTrade(correctedtrade),
			m_CorrectedValues(correctedvalues)
		{}

		QuotationTradeCancelCorrection const & operator =(QuotationTradeCancelCorrection const & c)
		{
			m_ContentMask = c.m_ContentMask;
			m_OriginalTrade = c.m_OriginalTrade;
			m_TradingSessionId = c.m_TradingSessionId;
			m_CorrectedTrade = c.m_CorrectedTrade;
			m_CorrectedValues = c.m_CorrectedValues;
			return *this;
		}

		bool operator ==(QuotationTradeCancelCorrection const & c) const
		{
			return (m_ContentMask == c.m_ContentMask) && (m_OriginalTrade == c.m_OriginalTrade) && (m_TradingSessionId == c.m_TradingSessionId) && (m_CorrectedTrade == c.m_CorrectedTrade) && (m_CorrectedValues == c.m_CorrectedValues);
		}

	public:
		TradeCancelCorrectionContentMask getContentMask() const { return m_ContentMask; }
		TradeCancelCorrectionContentMask & getContentMask() { return m_ContentMask; }
		TradeData const & getOriginalTrade() const { return m_OriginalTrade; }
		TradeData & getOriginalTrade() { return m_OriginalTrade; }
		FOSTradingSessionId getTradingSessionId() const { return m_TradingSessionId; }
		FOSTradingSessionId & getTradingSessionId() { return m_TradingSessionId; }
		TradeData const & getCorrectedTrade() const { return m_CorrectedTrade; }
		TradeData & getCorrectedTrade() { return m_CorrectedTrade; }
		ListOfQuotationVariable const & getCorrectedValues() const { return m_CorrectedValues; }
		ListOfQuotationVariable & getCorrectedValues() { return m_CorrectedValues; }

	public:
		void setContentMask(TradeCancelCorrectionContentMask contentmask) { m_ContentMask = contentmask; }
		void setOriginalTrade(TradeData const & originaltrade) { m_OriginalTrade = originaltrade; }
		void setTradingSessionId(FOSTradingSessionId tradingsessionid) { m_TradingSessionId = tradingsessionid; }
		void setCorrectedTrade(TradeData const & correctedtrade) { m_CorrectedTrade = correctedtrade; }
		void setCorrectedValues(ListOfQuotationVariable const & correctedvalues) { m_CorrectedValues = correctedvalues; }
		inline void swapCorrectedValues(ListOfQuotationVariable & correctedvalues) { m_CorrectedValues.swap(correctedvalues); }

	protected:
		TradeCancelCorrectionContentMask m_ContentMask;
		TradeData m_OriginalTrade;
		FOSTradingSessionId m_TradingSessionId;
		TradeData m_CorrectedTrade;
		ListOfQuotationVariable m_CorrectedValues;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <contentmask:TradeCancelCorrectionContentMask>\n"
			  << marge << "   ";
			TradeData::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   <tradingsessionid:FOSTradingSessionId>\n"
			  << marge << "   ";
			TradeData::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << "   ( <correctedvalues:QuotationVariable> )\n"
			  << marge << " }\n";
		}
};

/**

			HistoryIntradayExtended point with instrument code and trade ID
		
*/
class IntradayHistoryDataExtended
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_InstrCode);
			init_feedos_type (m_TradeId);
			init_feedos_type (m_IntradayPointExtended);
		}

		IntradayHistoryDataExtended() { reset(); }

		inline IntradayHistoryDataExtended(IntradayHistoryDataExtended const & c) :
			m_InstrCode(c.m_InstrCode),
			m_TradeId(c.m_TradeId),
			m_IntradayPointExtended(c.m_IntradayPointExtended)
		{}
		IntradayHistoryDataExtended(FOSInstrumentCode instrcode, String const & tradeid, IntradayHistoryPointExtended const & intradaypointextended) :
			m_InstrCode(instrcode),
			m_TradeId(tradeid),
			m_IntradayPointExtended(intradaypointextended)
		{}

		IntradayHistoryDataExtended const & operator =(IntradayHistoryDataExtended const & c)
		{
			m_InstrCode = c.m_InstrCode;
			m_TradeId = c.m_TradeId;
			m_IntradayPointExtended = c.m_IntradayPointExtended;
			return *this;
		}

		bool operator ==(IntradayHistoryDataExtended const & c) const
		{
			return (m_InstrCode == c.m_InstrCode) && (m_TradeId == c.m_TradeId) && (m_IntradayPointExtended == c.m_IntradayPointExtended);
		}

	public:
		FOSInstrumentCode getInstrCode() const { return m_InstrCode; }
		FOSInstrumentCode & getInstrCode() { return m_InstrCode; }
		String const & getTradeId() const { return m_TradeId; }
		String & getTradeId() { return m_TradeId; }
		IntradayHistoryPointExtended const & getIntradayPointExtended() const { return m_IntradayPointExtended; }
		IntradayHistoryPointExtended & getIntradayPointExtended() { return m_IntradayPointExtended; }

	public:
		void setInstrCode(FOSInstrumentCode instrcode) { m_InstrCode = instrcode; }
		void setTradeId(String const & tradeid) { m_TradeId = tradeid; }
		void setIntradayPointExtended(IntradayHistoryPointExtended const & intradaypointextended) { m_IntradayPointExtended = intradaypointextended; }

	protected:
		FOSInstrumentCode m_InstrCode;
		String m_TradeId;
		IntradayHistoryPointExtended m_IntradayPointExtended;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <instrcode:FOSInstrumentCode>\n"
			  << marge << "   <tradeid:String>\n"
			  << marge << "   ";
			IntradayHistoryPointExtended::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

typedef std::vector<IntradayHistoryDataExtended> ListOfIntradayHistoryDataExtended;

/**

			Cancel of a trade
		
*/
class IntradayHistoryCancel
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_InstrCode);
			init_feedos_type (m_TradeId);
			init_feedos_type (m_OriginalMarketTimestamp);
			init_feedos_type (m_FromVenue);
			init_feedos_type (m_OffBook);
		}

		IntradayHistoryCancel() { reset(); }

		inline IntradayHistoryCancel(IntradayHistoryCancel const & c) :
			m_InstrCode(c.m_InstrCode),
			m_TradeId(c.m_TradeId),
			m_OriginalMarketTimestamp(c.m_OriginalMarketTimestamp),
			m_FromVenue(c.m_FromVenue),
			m_OffBook(c.m_OffBook)
		{}
		IntradayHistoryCancel(FOSInstrumentCode instrcode, String const & tradeid, Timestamp const & originalmarkettimestamp, bool fromvenue, bool offbook) :
			m_InstrCode(instrcode),
			m_TradeId(tradeid),
			m_OriginalMarketTimestamp(originalmarkettimestamp),
			m_FromVenue(fromvenue),
			m_OffBook(offbook)
		{}

		IntradayHistoryCancel const & operator =(IntradayHistoryCancel const & c)
		{
			m_InstrCode = c.m_InstrCode;
			m_TradeId = c.m_TradeId;
			m_OriginalMarketTimestamp = c.m_OriginalMarketTimestamp;
			m_FromVenue = c.m_FromVenue;
			m_OffBook = c.m_OffBook;
			return *this;
		}

		bool operator ==(IntradayHistoryCancel const & c) const
		{
			return (m_InstrCode == c.m_InstrCode) && (m_TradeId == c.m_TradeId) && (m_OriginalMarketTimestamp == c.m_OriginalMarketTimestamp) && (m_FromVenue == c.m_FromVenue) && (m_OffBook == c.m_OffBook);
		}

	public:
		FOSInstrumentCode getInstrCode() const { return m_InstrCode; }
		FOSInstrumentCode & getInstrCode() { return m_InstrCode; }
		String const & getTradeId() const { return m_TradeId; }
		String & getTradeId() { return m_TradeId; }
		Timestamp const & getOriginalMarketTimestamp() const { return m_OriginalMarketTimestamp; }
		Timestamp & getOriginalMarketTimestamp() { return m_OriginalMarketTimestamp; }
		bool getFromVenue() const { return m_FromVenue; }
		bool & getFromVenue() { return m_FromVenue; }
		bool getOffBook() const { return m_OffBook; }
		bool & getOffBook() { return m_OffBook; }

	public:
		void setInstrCode(FOSInstrumentCode instrcode) { m_InstrCode = instrcode; }
		void setTradeId(String const & tradeid) { m_TradeId = tradeid; }
		void setOriginalMarketTimestamp(Timestamp const & originalmarkettimestamp) { m_OriginalMarketTimestamp = originalmarkettimestamp; }
		void setFromVenue(bool fromvenue) { m_FromVenue = fromvenue; }
		void setOffBook(bool offbook) { m_OffBook = offbook; }

	protected:
		FOSInstrumentCode m_InstrCode;
		String m_TradeId;
		Timestamp m_OriginalMarketTimestamp;
		bool m_FromVenue;
		bool m_OffBook;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <instrcode:FOSInstrumentCode>\n"
			  << marge << "   <tradeid:String>\n"
			  << marge << "   <originalmarkettimestamp:Timestamp>\n"
			  << marge << "   <fromvenue:bool>\n"
			  << marge << "   <offbook:bool>\n"
			  << marge << " }\n";
		}
};

/**

			Correction of a trade
		
*/
class IntradayHistoryCorrection
{
	public:
		inline void reset () { init_feedos_type (*this); }

		void _reset ()
		{
			init_feedos_type (m_InstrCode);
			init_feedos_type (m_TradeId);
			init_feedos_type (m_OriginalMarketTimestamp);
			init_feedos_type (m_FromVenue);
			init_feedos_type (m_OffBook);
			init_feedos_type (m_TradingSessionId);
			init_feedos_type (m_Trade);
		}

		IntradayHistoryCorrection() { reset(); }

		inline IntradayHistoryCorrection(IntradayHistoryCorrection const & c) :
			m_InstrCode(c.m_InstrCode),
			m_TradeId(c.m_TradeId),
			m_OriginalMarketTimestamp(c.m_OriginalMarketTimestamp),
			m_FromVenue(c.m_FromVenue),
			m_OffBook(c.m_OffBook),
			m_TradingSessionId(c.m_TradingSessionId),
			m_Trade(c.m_Trade)
		{}
		IntradayHistoryCorrection(FOSInstrumentCode instrcode, String const & tradeid, Timestamp const & originalmarkettimestamp, bool fromvenue, bool offbook, FOSTradingSessionId tradingsessionid, TradeData const & trade) :
			m_InstrCode(instrcode),
			m_TradeId(tradeid),
			m_OriginalMarketTimestamp(originalmarkettimestamp),
			m_FromVenue(fromvenue),
			m_OffBook(offbook),
			m_TradingSessionId(tradingsessionid),
			m_Trade(trade)
		{}

		IntradayHistoryCorrection const & operator =(IntradayHistoryCorrection const & c)
		{
			m_InstrCode = c.m_InstrCode;
			m_TradeId = c.m_TradeId;
			m_OriginalMarketTimestamp = c.m_OriginalMarketTimestamp;
			m_FromVenue = c.m_FromVenue;
			m_OffBook = c.m_OffBook;
			m_TradingSessionId = c.m_TradingSessionId;
			m_Trade = c.m_Trade;
			return *this;
		}

		bool operator ==(IntradayHistoryCorrection const & c) const
		{
			return (m_InstrCode == c.m_InstrCode) && (m_TradeId == c.m_TradeId) && (m_OriginalMarketTimestamp == c.m_OriginalMarketTimestamp) && (m_FromVenue == c.m_FromVenue) && (m_OffBook == c.m_OffBook) && (m_TradingSessionId == c.m_TradingSessionId) && (m_Trade == c.m_Trade);
		}

	public:
		FOSInstrumentCode getInstrCode() const { return m_InstrCode; }
		FOSInstrumentCode & getInstrCode() { return m_InstrCode; }
		String const & getTradeId() const { return m_TradeId; }
		String & getTradeId() { return m_TradeId; }
		Timestamp const & getOriginalMarketTimestamp() const { return m_OriginalMarketTimestamp; }
		Timestamp & getOriginalMarketTimestamp() { return m_OriginalMarketTimestamp; }
		bool getFromVenue() const { return m_FromVenue; }
		bool & getFromVenue() { return m_FromVenue; }
		bool getOffBook() const { return m_OffBook; }
		bool & getOffBook() { return m_OffBook; }
		FOSTradingSessionId getTradingSessionId() const { return m_TradingSessionId; }
		FOSTradingSessionId & getTradingSessionId() { return m_TradingSessionId; }
		TradeData const & getTrade() const { return m_Trade; }
		TradeData & getTrade() { return m_Trade; }

	public:
		void setInstrCode(FOSInstrumentCode instrcode) { m_InstrCode = instrcode; }
		void setTradeId(String const & tradeid) { m_TradeId = tradeid; }
		void setOriginalMarketTimestamp(Timestamp const & originalmarkettimestamp) { m_OriginalMarketTimestamp = originalmarkettimestamp; }
		void setFromVenue(bool fromvenue) { m_FromVenue = fromvenue; }
		void setOffBook(bool offbook) { m_OffBook = offbook; }
		void setTradingSessionId(FOSTradingSessionId tradingsessionid) { m_TradingSessionId = tradingsessionid; }
		void setTrade(TradeData const & trade) { m_Trade = trade; }

	protected:
		FOSInstrumentCode m_InstrCode;
		String m_TradeId;
		Timestamp m_OriginalMarketTimestamp;
		bool m_FromVenue;
		bool m_OffBook;
		FOSTradingSessionId m_TradingSessionId;
		TradeData m_Trade;

	public:
		static void dump_usage(std::ostream & o, std::string marge)
		{
			o << marge << " { <instrcode:FOSInstrumentCode>\n"
			  << marge << "   <tradeid:String>\n"
			  << marge << "   <originalmarkettimestamp:Timestamp>\n"
			  << marge << "   <fromvenue:bool>\n"
			  << marge << "   <offbook:bool>\n"
			  << marge << "   <tradingsessionid:FOSTradingSessionId>\n"
			  << marge << "   ";
			TradeData::dump_usage(o,marge+std::string("   "));
			o << ""
			  << marge << " }\n";
		}
};

//#ifdef FEEDOS_DONT_INCLUDE_OLD_HEADERS
}
//#endif
}

/************************************/
/** FeedOS                         **/
/**                                **/
/** copyright QuantHouse           **/
/************************************/

namespace FeedOS {

//#ifdef FEEDOS_DONT_INCLUDE_OLD_HEADERS
namespace Types {
//#endif

	/*
	inline void init_feedos_type (OrderBookEntryExtended & v)
	{
		init_feedos_type (v.getPrice());
		init_feedos_type (v.getQty());
		v.setNbOrders(-1);	// special value for "NOT VALID"
	}
	*/

//#ifdef FEEDOS_DONT_INCLUDE_OLD_HEADERS
}
//#endif

}

#endif
